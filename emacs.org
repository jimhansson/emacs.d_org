# -*- mode: org -*-
#+TITLE: My emacs configuration
#+AUTHOR: Jim Hansson
#+EMAIL: jim.hansson@gmail.com
#+DATE: <2012-06-28 to>
#+LANGUAGE: English
#+STARTUP: hidestars hideblocks
#+COLUMNS: %50ITEM %4TODO %20TAGS

This is my main .emacs file. It is responsible for calling out to the
local file at different points. This is placed in a git repository
that I share between work and home

* Introduction
  Basic things that could have been down throu custom-set-variable but
  then I would have harder time to replicate that between machines.

** Requirements

   - Emacs 24
   - a basic .emacs file that calls this after it inits org-babel 
   - a lot of extra packages. most configuration will check for it
     
** Other important stuff
*** Only load things that exists.

    that can be done this way, use this to avoid errors on machine
    which don't have every package installed.

    #+begin_example
      (when (require 'deft nil 'noerror) 
      (setq
         deft-extension "org"
         deft-directory "~/Org/deft/"
         deft-text-mode 'org-mode)
      (global-set-key (kbd "<f9>") 'deft))
    #+end_example

** Setup

   Here we setup some basic things, I dont like the toolbar so that we
   turn off, I use OrgMode to almost everything(even my .emacs) so
   that will be my default mode. Almost all computers I use are
   laptops and who in there right mind uses 12h clocks.

   #+begin_src emacs-lisp
     (setq user-full-name "Jim Hansson")
     (tool-bar-mode -1)
     (setq default-major-mode 'org-mode)
     (add-hook 'text-mode-hooxk 'turn-on-auto-fill)
     ;; show matching paren
     (show-paren-mode t)
     (iswitchb-mode 1)
     (setq filesets-data nil)
     (display-battery-mode)
     (global-font-lock-mode t)
     ;; binds ctrl + § to dabbrev as good enough completion 
     (global-set-key (kbd "C-\§") 'dabbrev-expand)
     (setq-default indent-tabs-mode t)
     ;; whitespace-mode things
     
     ;; less color in whitespace mode, The yellow and red is to distracting
     (setq whitespace-style (quote (spaces tabs newline space-mark 
                                           tab-mark newline-mark)))
     
     ;; make whitespace-mode use "" for newline and “” for tab.
     ;; together with the rest of its defaults
     (setq whitespace-display-mappings
           '(
             (space-mark 32 [183] [46]) ; normal space, ·
             (space-mark 160 [164] [95])
             (space-mark 2208 [2212] [95])
             (space-mark 2336 [2340] [95])
             (space-mark 3616 [3620] [95])
             (space-mark 3872 [3876] [95])
             (newline-mark 10 [8629 10]) ; newlne
             (tab-mark 9 [8677 9] [92 9]) ; tab
             ))
     
     (defun jiha-whitespace-cleanup ()
       (interactive)
       (let (whitespace-style (indentation::tab 
                               space-before-tab::tab
                               trailing))
         (whitespace-cleanup-region)))
     
   #+end_src

*** Modeline                                                       :modeline:
    
    #+begin_src emacs-lisp
      ;; Things that modifies the modeline
      (setq display-battery-mode t)
      (setq display-time-24hr-format t)
      ;; I work width some really big files and then it is good to have this
      ;; so i know how far down I am.
      (setq size-indication-mode t)
    #+end_src

** Uniquify                                                :uniquify:buffers:

   Better naming of buffers so we can easly tell the differens between
   buffers. Have some problem together with Iswitch

   #+begin_src emacs-lisp
     (require 'uniquify)
     (setq uniquify-buffer-name-style (quote post-forward))
   #+end_src

** Disable warnings for first time users
   
   For some reason some questions in emacs are yes/no and some are y/n
   this trips me sometimes so we turn that off, and the same goes for
   killing emacs. We also removes some questions that are asked to
   make sure that the users really wants what is going to happen, I
   know how to use undo and else I usually have some version control
   system running so I can go back.

   #+begin_src emacs-lisp
     ;; Changes all yes/no questions to y/n type
     (fset 'yes-or-no-p 'y-or-n-p)
     (set-variable 'confirm-kill-emacs 'yes-or-no-p)
     ;; more of these as I find them
     (put 'narrow-to-region 'disabled nil)
   #+end_src

* Auto complete

  #+begin_src emacs-lisp
    (add-to-list 'load-path (concat local-emacs-org-dir 
                                    "auto-complete"))
    (require 'auto-complete-config)
    (add-to-list 'ac-dictionary-directories (concat local-emacs-org-dir 
                                                    "ac-dicts"))
    (ac-config-default)
    ;;(define-key ac-mode-map (kbd "M-TAB") 'auto-complete)
    (ac-flyspell-workaround)
  #+end_src

* Iswitch Buffers                                                   :buffers:

  some text here.
  To prevent certain buffers from showing up in the completion list,
  set 'iswitchb-buffer-ignore': (setq iswitchb-buffer-ignore '("^ "
  "*Buffer")) This one is useful if you want to lose the *...*
  special buffers from the list. It's helpful if you're using the
  JDEE for editing Java apps, as you end up with buffers named
  org.whatever.package.Class which you might want to eliminate: (setq
  iswitchb-buffer-ignore '("^\\*")) To prevent switching to another
  frame, you can add the following to your configuration: (setq
  iswitchb-default-method 'samewindow)

  #+begin_src emacs-lisp
    (iswitchb-mode 1)
    ;; rebind the normal key for buffer list to ibuffer
    (global-set-key (kbd "C-x C-b") 'ibuffer)
    (setq ibuffer-expert t)
    (setq ibuffer-show-empty-filter-groups nil)
    (setq iswitchb-default-method 'samewindow)
    ;; in your .emacs will allow left/right artist--arrow key navigation of the
    ;; buffer list, and deactivate up/down in iswitchb. Note that you
    ;; can by default use C-s and C-r to do this.  If the
    ;; below fails with "define-key: Symbol's function definition is
    ;; void: edmacro-parse-keys" you need to load the package defining
    ;; edmacro with (require 'edmacro).
    (defun iswitchb-local-keys ()
      (mapc (lambda (K) 
              (let* ((key (car K)) (fun (cdr K)))
                (define-key iswitchb-mode-map (edmacro-parse-keys key) fun)))
            '(("<right>" . iswitchb-next-match)
              ("<left>"  . iswitchb-prev-match)
              ("<up>"    . ignore             )
              ("<down>"  . ignore             ))))
    (add-hook 'iswitchb-define-mode-map-hook 'iswitchb-local-keys)
  #+end_src
  
  #+begin_src emacs-lisp
    (setq ibuffer-saved-filter-groups
          '(("home"
             ("Emacs" (or (filename . ".emacs.d")
                          (filename . "emacs.org")
                          (filename . ".emacs")))
             ("Org" (or (filename . ".org")
                        (filename . "OrgMode")
                        (name . "*Org Agenda*")
                        (name . "diary")))
             ("code" (or (mode . csharp-mode)
                         (mode . c++-mode)
                         (mode . lisp-mode)))
             ("Web Dev" (or (mode . html-mode)
                            (mode . css-mode)))
             ("SQL" (or (filename . ".plb")
                        (filename . ".sql")
                        (mode . sqli-mode)
                        (name . "*SQL*")))
             ("VC" (or (name . "\*svn")
                       (name . "\*magit")))
             ("ERC" (mode . erc-mode))
             ("gnus" (or
                      (mode . message-mode)
                      (mode . bbdb-mode)
                      (mode . mail-mode)
                      (mode . gnus-group-mode)
                      (mode . gnus-summary-mode)
                      (mode . gnus-article-mode)
                      (name . "^\\.bbdb$")
                      (name . "^\\.newsrc-dribble")))
             ("Help" (or (name . "\*Help\*")
                         (name . "\*Apropos\*")
                         (name . "\*info\*"))))))
        
        (add-hook 'ibuffer-mode-hook 
                  '(lambda ()
                     (ibuffer-auto-mode 1)
                     (ibuffer-switch-to-saved-filter-groups "home")))
        
        ;; Switching to ibuffer puts the cursor on the most recent buffer
        (defadvice ibuffer (around ibuffer-point-to-most-recent) ()
          "Open ibuffer with cursor pointed to most recent buffer name"
          (let ((recent-buffer-name (buffer-name)))
            ad-do-it
            (ibuffer-jump-to-buffer recent-buffer-name)))
        (ad-activate 'ibuffer)
        
        
        (setq ibuffer-formats
              '((mark modified read-only " "
                      (name 25 25 :left :elide) " "
                      (size 9 -1 :right) " "
                      (mode 16 16 :left :elide) " " filename-and-process)
                (mark " " (name 16 -1) " " filename)))
    
     
    (defun switch-buffers-between-frames ()
      "switch-buffers-between-frames switches the buffers between the two last frames"
      (interactive)
      (let ((this-frame-buffer nil)
            (other-frame-buffer nil))
        (setq this-frame-buffer (car (frame-parameter nil 'buffer-list)))
        (other-frame 1)
        (setq other-frame-buffer (car (frame-parameter nil 'buffer-list)))
        (switch-to-buffer this-frame-buffer)
        (other-frame 1)
        (switch-to-buffer other-frame-buffer)))
    
  #+end_src
  
** Iswitch and uniquify compabilitiy                                :uniquify:

   The library uniquify overrides Emacs default mechanism for making
   buffer names unique (using suffixes like <2>, <3> etc.) with a
   more sensible behaviour which use parts of the file names to make
   the buffer names distinguishable.  Additionally one can configure
   uniquify to rework the buffer names whenever a buffer is
   killed. This feature does not play well with IswitchBuffers
   function iswitchb-kill-buffer, bound to C-k. The following code
   instructs iswitchb-kill-buffer to update the buffer list after
   killing a buffer, so that a possible buffer renaming by uniquify
   is taken in account.

   #+begin_src emacs-lisp
     (defadvice iswitchb-kill-buffer (after rescan-after-kill activate)
       "*Regenerate the list of matching buffer names after a kill.
     Nextcessary if using `uniquify' with `uniquify-after-kill-buffer-p'
     set to non-nil."
       (setq iswitchb-buflist iswitchb-matches)
       (iswitchb-rescan))
     
     (defun iswitchb-rescan ()
       "*Regenerate the list of matching buffer names."
       (interactive)
       (iswitchb-make-buflist iswitchb-default)
       (setq iswitchb-rescan t))
   #+end_src

** More Iswitch things that I don't use at the moment
*** Keybindings

    Something most IswitchBuffers users aren't aware of is that you
    can hit C-k to kill the currently selected buffer.

*** Using Iswitch-Buffer Programmatically
    
    From: KinCho
    Subject: my-icompleting-read
    Newsgroups: gnu.emacs.sources
    Date: Tue, 09 Oct 2001 16:28:18 GMT
    
    I used iswitchb for a while and really liked it. I began to
    explore to see if I can borrow iswitchb to make my scripts work
    like iswitchb as well. Well, it turned out iswitchb is coded in a
    way that makdes it really easy to borrow it to do regex-style
    completing-read: 

    #+begin_example emacs-lisp
    (defun my-icompleting-read(prompt choices)
    (let ((iswitchb-make-buflist-hook
    (lambda ()
    (setq iswitchb-temp-buflist choices))))
    (iswitchb-read-buffer prompt)))
    #+end_example

    Another example. Two things. "nil t" to iswitchb-read-buffer
    requires a choice from the given list with no default. Using an
    flet is a way to work when there's no hook variable. There is a
    hook variable. 

    #+begin_example emacs-lisp
    (defvar interesting  (regexp-opt '(".c" ".h" "etc.")))
    (defvar some-directory "/home/somewhere/etc/")

    ;; Making this more flexible is an exercise for the reader
    (defun find-a-file (arg &optional non-selective)
    "Select files using substrings."
    (interactive "sFile: ")
    (let ((dir (expand-file-name some-directory))
    candidates)
    (flet ((file-match (file)
    (if non-selective
    (string-match arg file)
    (and
    (string-match interesting file)
    (string-match arg file)))))
    (setq candidates (delq nil (loop for file in (directory-files dir)
    collect (if (file-match file) file)))))
    (cond
    ((eq (length candidates) 1)
    (find-file (format "%s%s" dir (car candidates))))
    ((eq (length candidates) 0)
    (if non-selective
    (message "No such file!")
    (find-a-file arg t)))
      (t
      (flet ((iswitchb-make-buflist (default)
      (setq iswitchb-buflist candidates)))
      (find-file (format 
      "%s%s" dir
      (iswitchb-read-buffer "File: " nil t))))))))
    #+end_example
      
    I'm quite new to iswitchb. I've been after eliminating the need to
    confirm (with TAB or ret) the last left possibility. 
      
    I've started with this simple hack, which only displays the
    desired buffer, but in this way, i don't need to look at the
    minibuffer (in some cases). 
    
    #+begin_example emacs-lisp
    (defun iswitchb-post-command ()
    "Run after command in 'iswitchb-buffer'."
    (iswitchb-exhibit)
    (if (= (length iswitchb-matches) 1)
    (display-buffer (car iswitchb-matches))))
    #+end_example
    
    another thing i like, is to have the freedom to decide to open the
    buffer in other-window/frame after i made the selection: Hence a
    new minibuffer exiting command: 
    
    #+begin_example emacs-lisp
    (defun iswitchb-select-buffer-other-window ()
    "Select the buffer named by the prompt. But in another window."
    (interactive)
    (setq iswitchb-method 'otherwindow)
    (exit-minibuffer))
    #+end_example
    
    The functionality of iswitchb can also be used to provide a
    replacement for the usual behaviour of find-file. Instead of
    hitting Tab to bring up a buffer listing the possible file
    completions, a list of file completions is continuously updated in
    the minibuffer: 
    
    #+begin_example emacs-lisp
    (defun exd-find-file ()
    "Use functionality from `iswitchb' as a replacement for `find-file'"
    (interactive)
    (find-file (exd-iswitchb-find-file "." (directory-files "."))))
    
    (defun exd-iswitchb-find-file (dir file-list)
    "Use functionality from `iswitchb' to select a file for `find-file'.
    If a directory is selected, enter that directory and generate a new
    list from which to select a file."
    ;; sort the file list into directories first
    (setq file-list
    (sort file-list
    (lambda (elt-1 elt-2)
    (and (file-directory-p (concat dir "/" elt-1))
    (not (file-directory-p (concat dir "/" elt-2)))))))
    ;; use iswitchb for minibuffer file list/completion magic
    (let* (resize-mini-windows
    (iswitchb-make-buflist-hook
    (lambda ()
    (setq iswitchb-temp-buflist file-list)))
    ;; get the selected file
    (selected-file (concat dir "/" (iswitchb-read-buffer
    (concat "Find File: "
    (expand-file-name dir)
    "/")))))
    ;; if the selected file is a directory, recurse, else return file
    (if (file-directory-p selected-file)
    (exd-iswitchb-find-file selected-file (directory-files selected-file))
    selected-file)))
    #+end_example
    
    See Also:
    
    Icicles, and command 'icicle-buffer', which is similar to
    'iswitchb-buffer' but provides some additional features. Also,
    Icicles treats all types of minibuffer input the same way:
    filenames, buffer names, commands, variables...everything. And it
    lets you use a regexp to match completions, if you like. 
    InteractivelyDoThings (ido), which implements regex selection for
    files, directory buffers etc...

* Buffer Menu
** TODO Font lock                                                   :fontlock:

   If you use ElectricBufferList, then simply use this instead for the
   last line:
   (add-hook 'electric-buffer-menu-mode-hook 'buffer-menu-custom-font-lock)
   
   need to put the right colors on this.
   #+begin_src emacs-lisp
     (setq buffer-menu-buffer-font-lock-keywords
           '(("^....[*]Man .*Man.*"   . font-lock-variable-name-face) ;Man page
             (".*Dired.*"             . font-lock-comment-face)       ; Dired
             ("^....[*]shell.*"       . font-lock-preprocessor-face)  ; shell buff
             (".*[*]scratch[*].*"     . font-lock-function-name-face) ; scratch buffer
             ("^....[*].*"            . font-lock-string-face)        ; "*" named buffers
             ("^..[*].*"              . font-lock-constant-face)      ; Modified
             ("^.[%].*"               . font-lock-keyword-face)))     ; Read only
     
     (defun buffer-menu-custom-font-lock  ()
       (let ((font-lock-unfontify-region-function
              (lambda (start end)
                (remove-text-properties start end '(font-lock-face nil)))))
         (font-lock-unfontify-buffer)
         (set (make-local-variable 'font-lock-defaults)
              '(buffer-menu-buffer-font-lock-keywords t))
         (font-lock-fontify-buffer)))
     
     (add-hook 'buffer-menu-mode-hook 'buffer-menu-custom-font-lock)
    #+end_src

* TODO Coding

  Here I will place everything that has todo with coding

** Flymake
*** Flymake Cursor

    The normal operation of flymake allows the user to see the error
    message for a particular line by “hovering” the mouse over the
    line. This is inconvenient for people who try to use the keyboard
    for all input. FlymakeCursor was designed to address that: it
    displays the flymake error in the minibuffer region, when the
    cursor is placed on a line containing a flymake error. 

    This works in any language that flymake supports

    #+begin_src emacs-lisp
      (load-file (concat local-emacs-org-dir "flymake-cursor.el"))
    #+end_src
** Compile  
** TODO Coding styles
   check out [[http://emacswiki.org/emacs/IndentingC#toc2][emacswiki on indenting]]
*** Microsoft C & C++ style

    Here is a style that pretty much matches the observed style of
    Microsoft (R)'s C and C++ code.

    #+begin_src emacs-lisp
      (c-add-style "microsoft"
                   '("stroustrup"
                     (c-offsets-alist
                      (innamespace . -)
                      (inline-open . 0)
                      (inher-cont . c-lineup-multi-inher)
                      (arglist-cont-nonempty . +)
                      (template-args-cont . +))))
      
    #+end_src

*** OpenBSD style

    Style for OpenBSD? source code, also valid for OpenSSH? and other
    BSD based OSs source.

    #+begin_src emacs-lisp
      (c-add-style "openbsd"
                   '("bsd"
                     (indent-tabs-mode . t)
                     (defun-block-intro . 8)
                     (statement-block-intro . 8)
                     (statement-case-intro . 8)
                     (substatement-open . 4)
                     (substatement . 8)
                     (arglist-cont-nonempty . 4)
                     (inclass . 8)
                     (knr-argdecl-intro . 8)))
    #+end_src
** Visual Studio Integration

   Integration with VS, We have aseperate file with commands to tell
   visual studio to do things. at the moment we only have to commands
   but it should be simple to extend it with others.
   #+begin_src emacs-lisp
     ;; this should only be done on windows to save startup time.
     (org-babel-load-file (concat local-emacs-org-dir "devenv-tricks.org"))
     ;; Now in those mode where it might be useful do something like
     ;;(global-set-key [f9] 'devenv-toggle-breakpoint)
     ;;(global-set-key [f5] 'devenv-debug)
     (global-set-key [f3] 'devenv-switch-to-devenv)
   #+end_src

** TODO CEDET

   Use a local installation of CEDET so we have control over what
   version we use. This means that we should not use any version from
   ELPA or local package system.

   #+begin_src emacs-lisp
     (require 'edmacro)
     ;; using my own
     (load-file (concat local-emacs-org-dir "cedet-1.1/common/cedet.el"))
     (global-ede-mode t)                      ; Enable the Project management system
     (semantic-load-enable-code-helpers)      ; Enable prototype help and smart completion 
     (global-srecode-minor-mode 1)
   #+end_src
   
   #+begin_src emacs-lisp
   ;;  (require 'semantic)
   #+end_src

*** EDE
    #+begin_src emacs-lisp
    ;;  (global-ede-mode t)
    #+end_src

*** Code helpers

    #+begin_src emacs-lisp
    ;;  (semantic-load-enable-excessive-code-helpers)
    #+end_src

** TODO Completion
*** Language
**** C#
     
     #+begin_src emacs-lisp
       (add-to-list 'load-path (concat local-emacs-org-dir "csharp"))
     #+end_src

     The `cscomp-assembly-search-paths' should hold a list of
     directories to search for assemblies that get referenced via using
     clauses in the modules you edit.  This will try default to
     something reasonable, including the "typical" .NET 2.0 and 3.5
     directories, as well as the default locations for reference
     assemblies.  If you have non-default locations for these things,
     you should set them here. Also, if you have other libraries (for
     example, the WCF Rest Starter kit, or the Windows Automation
     assemblies) that you reference within your code, you can include
     the appropriate directory in this list.
    
     #+begin_example emacs-lisp
      (eval-after-load "csharp-completion"
       '(progn
          (setq cscomp-assembly-search-paths
            (list "c:\\.net3.5ra"    ;; <<- locations of reference assemblies
                  "c:\\.net3.0ra"    ;; <<-
                  "c:\\.net2.0"      ;; <<- location of .NET Framework assemblies
                  "c:\\.net3.5"      ;; <<- ditto
          ))))
     #+end_example

     #+begin_src emacs-lisp
        ;; only on windows do we use csharp completion.
       
       (when (require 'powershell nil 'noerror)
         (when (require 'csharp-completion nil 'noerror) 
           (defun jiha-csharp-mode-hook  
             ;; C# code completion
             (load-file (concat local-emacs-org-dir "csharp/csharp-completion.el"))
             ;;(csharp-analysis-mode 1)
             ;;(local-set-key "\M-\\"   'cscomp-complete-at-point)
             ;;(local-set-key "\M-§."   'cscomp-complete-at-point-menu)
             )
         
           (add-to-list 'csharp-mode-hook
                        'jiha-csharp-mode-hook))
       )
       
     #+end_src
** Indentation

   I usually use tabs for indentation and spaces for alignment, Emacs
   are one of the few eviroment that support that kind of thing. I
   like a low c-basic-offset 2

   #+begin_src emacs-lisp
     ;; use tabs for indentation later we setup spaces for alignment.
     (setq-default indent-tabs-mode t)
     ;; I want as much as possible on my screens.
     (setq-default c-basic-offset 2)
     (setq-default tab-width 2) ; or any other preferred value
   #+end_src
   
   #+begin_src emacs-lisp
     ;; smart tabs, tabs for indentation, spaces for alignment
     (defadvice align (around smart-tabs activate)
       (let ((indent-tabs-mode nil)) ad-do-it))
     
     (defadvice align-regexp (around smart-tabs activate)
       (let ((indent-tabs-mode nil)) ad-do-it))
     
     (defadvice indent-relative (around smart-tabs activate)
       (let ((indent-tabs-mode nil)) ad-do-it))
     
     (defadvice indent-according-to-mode (around smart-tabs activate)
       (let ((indent-tabs-mode indent-tabs-mode))
         (if (memq indent-line-function
                   '(indent-relative
                     indent-relative-maybe))
             (setq indent-tabs-mode nil))
         ad-do-it))
     
     (defmacro smart-tabs-advice (function offset)
       `(progn
          (defvaralias ',offset 'tab-width)
          (defadvice ,function (around smart-tabs activate)
            (cond
             (indent-tabs-mode
              (save-excursion
                (beginning-of-line)
                (while (looking-at "\t*\\( +\\)\t+")
                  (replace-match "" nil nil nil 1)))
              (setq tab-width tab-width)
              (let ((tab-width fill-column)
                    (,offset fill-column)
                    (wstart (window-start)))
                (unwind-protect
                    (progn ad-do-it)
                  (set-window-start (selected-window) wstart))))
             (t
              ad-do-it)))))
     
     (smart-tabs-advice c-indent-line c-basic-offset)
     (smart-tabs-advice c-indent-region c-basic-offset)
     ;; smart tabs - end
   #+end_src

*** SQL

   #+begin_src emacs-lisp
     (eval-after-load "sql"
       '(load-library "sql-indent"))
   #+end_src


* Fly-spell

  My spelling is terrible so we use fly-spell as much as possible when
  it is available. We turn it on for most text-modes and
  flyspell-prog-mode for programming. 

  I highly suggest setting ‘flyspell-issue-message-flag’ to nil, as
  printing messages for every word (when checking the entire buffer)
  causes an enormous slowdown. 

  deactivated at the moment until we have fixed cygwin ispell or
  aspell.
  #+begin_example emacs-lisp
    (when (require 'flyspell nil 'noerror)
      ;; activate flyspell for text-mode and derivatives
      (dolist (hook '(text-mode-hook))
        (add-hook hook (lambda () (flyspell-mode 1))))
      ;; this is how we remove it for a sub-mode
      ;;(dolist (hook '(change-log-mode-hook log-edit-mode-hook))
      ;;  (add-hook hook (lambda () (flyspell-mode -1))))
      )

    (setq flyspell-issue-message-flag nil)
  #+end_example

** Fly-spell for comments when programming                            :coding:

   #+begin_src emacs-lisp
     ;; Flyspell in C based programming modes
     (add-hook 'c-mode-hook
               (lambda ()
                 (flyspell-prog-mode)))
     
     ;; Flyspell in C++ based programming modes
     (add-hook 'c++-mode-hook
               (lambda ()
                 (flyspell-prog-mode)))
     
     ;; Flyspell in emacs-lisp mode
     (add-hook 'lisp-mode-hook
               (lambda ()
                 (flyspell-prog-mode)))
   #+end_src

** TODO word-list for org-files.
   
   org-files contains some reserved words like #+begin_* ... these
   should be included in some sort of wordlist we use. so we don't get
   a lot of errors on those files.

** TODO don't use flyspell in src samples
   
   Or switch to flyspell-prog-mode somehow.

** TODO Avoid false positives

   I recently started using flyspell and am enjoying its features. Is
   there a way to disable flyspell for certain regexps? For instance,
   I would like to disable flyspell when typing a url. Otherwise, when
   entering a url such as
   http://www.emacswiki.org/cgi-bin/emacs/FlySpell, www, emacswiki,
   cgi and FlySpell are highlighted as errors. Any advice would be
   greatly appreciated. – MattLundin 

   There is only one way, using flyspell-generic-check-word-predicate
   which should be a function. In such a function you can use thing at
   point. 

   However it is a bit difficult to manage this as this variable may
   be only one function. I have submitted a patch to Emacs devel to
   take care of this. 

   Thanks for pointing me to the flyspell-generic-check-word-predicate
   variable. – MattLundin

** TODO Windows
   
   we need to install cygwin and use aspell.
   http://curiousprogrammer.wordpress.com/2009/04/25/flyspell-windows/

** TODO somehow use #+LANGUAGE in org to choose wordlist.
** Other flyspell things
*** Change dictionaries

    As I often need to switch between English and German I use this
    function:

    #+begin_example emacs-lisp
      (defun fd-switch-dictionary()
      (interactive)
      (let* ((dic ispell-current-dictionary)
    	 (change (if (string= dic "deutsch8") "english" "deutsch8")))
        (ispell-change-dictionary change)
        (message "Dictionary switched from %s to %s" dic change)
        ))
    
      (global-set-key (kbd "<f8>")   'fd-switch-dictionary)
    #+end_example

    I too cycle through different languages, but not all that is
    available in the system. I use the following code inside my
    .emacs. 

    #+begin_example emacs-lisp
    (let ((langs '("american" "francais" "brasileiro")))
      (setq lang-ring (make-ring (length langs)))
      (dolist (elem langs) (ring-insert lang-ring elem)))

    (defun cycle-ispell-languages ()
      (interactive)
      (let ((lang (ring-ref lang-ring -1)))
        (ring-insert lang-ring lang)
        (ispell-change-dictionary lang)))

    (global-set-key [f6] 'cycle-ispell-languages)
    #+end_example

    How can I ignore or add a word without using the popup menu?

    Use flyspell-auto-correct-word.

    This is not working for me. With flyspell-auto-correct-word I can
    go through all suggestions for correction, but I do not get an
    option to insert the word into my dictionary. Success in adding
    new words into the personal dictionary.

    I used “M x ispell-region”, and the words that ispell considered
    having incorrect spellings were highlighted. The point moved to
    the first “mis-spelled” word. By typing “i”, I inserted the word
    into my personal dictionary. Later I found that the personal
    dictionary was stored in the file $HOME/.aspell.en.pws in pure
    text format. Although the word was added when I used “ispell”
    instead of “flyspell”, but once added, flyspell also recognized
    the word as having a correct spelling. :-) This information came
    from the web page:
    http://www.delorie.com/gnu/docs/emacs/emacs_109.html . Thanks! 

    Easy Spell Check: key bindings and function to make
    FlySpell/ispell/aspell easy to use w/ out a mouse 

    Place the below code in your .emacs

    F8 will call ispell (or aspell, etc) for the word the cursor is on
    (or near). You can also use the built-in key binding
    M-$. Ctrl-Shift-F8 enables/disables FlySpell for your current
    buffer (highlights misspelled words as you type) Crtl-Meta-F8 runs
    FlySpell on your current buffer (highlights all misspelled words
    in the buffer) Ctrl-F8 calls ispell for the FlySpell highlighted
    word prior to the cursor’s position Meta-F8 calls ispell for the
    FlySpell highlighted word after the cursor’s position.

    #+begin_example emacs-lisp
      ;; easy spell check
      (global-set-key (kbd "<f8>") 'ispell-word)
      (global-set-key (kbd "C-S-<f8>") 'flyspell-mode)
      (global-set-key (kbd "C-M-<f8>") 'flyspell-buffer)
      (global-set-key (kbd "C-<f8>") 'flyspell-check-previous-highlighted-word)
      (defun flyspell-check-next-highlighted-word ()
        "Custom function to spell check next highlighted word"
        (interactive)
        (flyspell-goto-next-error)
        (ispell-word)
        )
      (global-set-key (kbd "M-<f8>") 'flyspell-check-next-highlighted-word)
#+end_example

* TODO OrgMode

** TODO Rework 

   this to support more that 2 different org directories and to not
   make a difference bewtween them as much as possible.

    (setq org-directory "~/Dokument/orgfiles/")
    (setq org-default-notes-file "~/.notes")

** Basic

   #+begin_src emacs-lisp
     ;; do not have so much in my agenda so two weeks is good
     (setq org-agenda-ndays 14)
     (setq org-deadline-warning-days 14)
     (setq org-timeline-show-empty-dates t)
     (setq org-agenda-repeating-timestamp-show-all nil)
     (setq org-agenda-include-diary t)
     (setq org-feed-alist)
     (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
     (setq org-insert-mode-line-in-empty-file t)
     ;; setup automatic expiring of old entries with creation date
     ;; if entries does not have creation date they will never expire.
     (load-file (concat local-emacs-org-dir "org-modules/org-expiry.el"))
     (setq org-expiry-wait "+2m")
     ;;(org-expiry-insinuate)
     (load-file (concat local-emacs-org-dir "org-modules/org-toc.el"))
     (require 'org-crypt)
     (org-crypt-use-before-save-magic)
     (setq org-tags-exclude-from-inheritance (quote ("crypt")))
     (run-at-time "00:59" 3600 'org-save-all-org-buffers)
   #+end_src
   
   A large part of the configuration has to do with how org should
   behave. it's a pretty complex mode with lot of things you could
   change. I have tried to make it as simple a possible with sub-trees
   for every main function of OrgMode.

    (setq org-agenda-exporter-settings
          '((ps-number-of-columns 1)
            (ps-landscape-mode t)
            (htmlize-output-type 'css)))
    
    (setq org-agenda-custom-commands
          '(
            
            ("P" "Projects"   
             ((tags "PROJECT")))
            
            ("H" "Office and Home Lists"
             ((agenda)
              (tags-todo "OFFICE")
              (tags-todo "HOME")
              (tags-todo "COMPUTER")
              (tags-todo "DVD")
              (tags-todo "READING")))
            
            ("D" "Daily Action List"
             (
              (agenda "" ((org-agenda-ndays 1)
                          (org-agenda-sorting-strategy
                           (quote ((agenda time-up priority-down tag-up) )))
                          (org-deadline-warning-days 0)
                          ))))
            )
          )
    
    (defun gtd ()
      (interactive)
      (find-file "~/Dokument/GTD/gtd.org")
      )
    (global-set-key (kbd "C-c g") 'gtd)
    
    (add-hook 'org-agenda-mode-hook 'hl-line-mode)

** Init

   because I have more than one computer and also a work computer, I
   have split my org agenda files into two parts. One that I share
   between computers and one that is local to that machine(or
   filesystem I am working in). To Make configuration of org-agenda
   work with this I have files that I call in my shared org directory
   and in my local directory. So here is the first call.

   #+begin_src emacs-lisp
     (org-babel-load-file (concat local-org-files-dir "init.org"))
     (org-babel-load-file (concat shared-org-files-dir "init.org"))
   #+end_src
   
** Smarter headlines

   from: http://lists.gnu.org/archive/html/emacs-orgmode/2007-10/msg00551.html
   Hi,
   
   Here's a small piece of elisp code that might be useful to some of
   you.  Pressing '*' now inserts '*' as before, but if there are only
   spaces between the beginning of the current line and the point,
   then all of them are converted to stars.  Useful for inserting new
   headlines.
   
   Longer explanaition: assume you have the following structure:
   
   * first level headline
   _* second level headline
   __* third level headline

   (_ denotes an invisible star) Since stars are invisible, I often
   find myself trying to create a new subheadline by just inserting a
   single star

   * first level headline
   _* second level headline
   __* third level headline
      *

   which of course doesn't normally work, hence this elisp code.

   #+begin_src emacs-lisp
     (defun local-org-insert-stars ()
       (interactive)
       (when (looking-back "^ *" (point-at-bol))
         (replace-string " " "*" nil (point-at-bol) (point)))
       (insert "*"))
     
     (define-key org-mode-map "*" 'local-org-insert-stars)
   #+end_src
   Haven't thoroughly tested it, but it seems to work ok.

   Piotr

** Filesets for OrgFiles                                           :filesets:
   
   A Nice fileset definition for my local org files and one for my shared org files.
   #+begin_src emacs-lisp
     ;; for some reason I don't understand this does not work, must have
     ;; something todo evaluation of variables.
     ;;(add-to-list 'filesets-data (quote ("OrgFiles" 
     ;;                                    (:tree local-org-files-dir 
     ;;                                           "^.+\\.org$")
     ;;                                    (:tree-max-level 2))))
     ;;(add-to-list 'filesets-data (quote ("OrgFiles" 
     ;;                                    (:tree shared-org-files-dir 
     ;;                                           "^.+\\.org$")
     ;;                                    (:tree-max-level 2))))
     
   #+end_src

** Logging and clocking
   
   I want to have the change to enter a message for every change a
   make to items that are scheduled and for what I make with my
   time. It's easy to ignore if not needed I just pres C-c C-c, and no
   message will be saved.

   #+begin_src emacs-lisp
     (setq org-clock-into-drawer t)
     (setq org-log-into-drawer t)
     (setq org-log-redeadline (quote note))
     ;; resurrect clock and clocking history
     ;; this need to be placed after Local and Shared init of org-files so
     ;; we have all files where we should look for clocked in tasks.
     (org-clock-persistence-insinuate)     
   #+end_src
   
   #+begin_src emacs-lisp

   #+end_src
** Agenda
   
   #+begin_src emacs-lisp
      ;; does not work at the moment
     (setq org-agenda-custom-commands
           '(("d" "Upcoming deadlines" agenda "" 
              ((org-agenda-time-grid nil)
               (org-deadline-warning-days 365)        ;; [1]
               (org-agenda-entry-types '(:deadline))  ;; [2]
               ))
             ;; other commands go here
             ))
   #+end_src

** TODO Exports
** Babel
*** SQL
    Sometimes I use sql in org-babel, for that I have modified version
    of 'ob-sql.el' my modifications are so I can use it together with
    oracle. It still need some more fixing before a send a patch for it
    to the maintainers.

    #+begin_src emacs-lisp
      ;; we use a safe way of loading it, it should alawys exist but if it
      ;; does not, we don't want an error.
      (when (require 'ob-sql nil 'noerror) 
        (message "loaded ob-sql, you can now use sql in org-babel snippets")
        )
    #+end_src

** Post

   Read [[Init]]. here is the last call and it gives the local a chance to
   overide everything from the shared org-directory.

   #+begin_src emacs-lisp
     (org-babel-load-file (concat shared-org-files-dir "post.org"))
     (org-babel-load-file (concat local-org-files-dir "post.org"))
   #+end_src

* Remember
  
  I don't use remember as much at the moment but some day or some
  other function once I have found out which I shall use. Most of this
  has been copied from someones GTD.org setup.

  #+begin_src emacs-lisp
    (autoload 'remember "remember" nil t)
    (autoload 'remember-region "remember" nil t)
    (setq remember-annotation-functions '(org-remember-annotation))
    (setq remember-handler-functions '(org-remember-handler))
    (add-hook 'remember-mode-hook 'org-remember-apply-template)
    (setq org-remember-templates
         '(
          ("Todo" ?t "** TODO %^{Brief Description} %^g\n%?\nAdded: %U" "~/Dokument/GTD/gtd.org" "Tasks")
          ("Private" ?p "\n* %^{topic} %T \n%i%?\n" "~/Dokument/GTD/gtd.org" "Private")
          ("WordofDay" ?w "\n* %^{topic} \n%i%?\n" "~/Dokument/GTD/wotd.org")
          ))
  #+end_src

* TODO Other Setup

  #+begin_src emacs-lisp
    ; dont use tabs for indenting
    (setq-default indent-tabs-mode nil)
    
    (define-key global-map "\C-cl" 'org-store-link)
    (define-key global-map "\C-ca" 'org-agenda)
    
    (define-key global-map "\C-cr" 'org-remember)
        
    (define-key global-map [f8] 'remember)
    (define-key global-map [f9] 'remember-region)
        
    (global-set-key "\C-x\C-r" 'prefix-region)
    (global-set-key "\C-x\C-l" 'goto-line)
    ;;(global-set-key "\C-x\C-y" 'copy-region-as-kill)
  #+end_src

* Load Local settings

  Last but not least we need to load the part of the .emacs that is
  local to this machine. That is also a org-babel emacs file.

  #+begin_src emacs-lisp
    (add-to-list 'load-path (concat local-emacs-org-dir "local"))
    (org-babel-load-file (concat local-emacs-org-dir "local/emacs.org"))
  #+end_src

* Filesets                                                          :filesets:

The commands that can operate on file sets are specified in the global
custom variable "filesets-commands". You can add your own commands to
that list. The default value for this variable is: 

("Isearch" multi-isearch-files
  (filesets-cmd-isearch-getargs))
 ("Isearch (regexp)" multi-isearch-files-regexp
  (filesets-cmd-isearch-getargs))
 ("Query Replace" perform-replace
  (filesets-cmd-query-replace-getargs))
 ("Query Replace (regexp)" perform-replace
  (filesets-cmd-query-replace-regexp-getargs))
 ("Grep <<selection>>" "grep"
  ("-n " filesets-get-quoted-selection " " "<<file-name>>"))
 ("Run Shell Command" filesets-cmd-shell-command
  (filesets-cmd-shell-command-getargs)))

The values consist of an association list of names, functions, and an
argument list (or a function that returns one) to be run on a
filesets' files. So, if you wanted to add a command that does an
"occur" command on the file set, you could use the "Isearch" entry as
an example to create your own new entry (that you would add to the
"filesets-commands" global variable) that would look something like: 

 ("Occur (regexp)" multi-occur-files-regexp
  (filesets-cmd-occur-getargs))

You would need to write the "multi-occur-files-regexp" and
"filesets-cmd-occur-getargs" functions (you could use the existing
"multi-isearch-files-regexp" and "filesets-cmd-isearch-getargs"
functions as a basis since they would be similar). The same would
apply for any additional Emacs command that you wanted to add to work
on file sets. 

  #+begin_src emacs-lisp
    ;; now when both shared and local config has been parsed we should be
    ;; able to init the filesets menu.
    (filesets-init)
  #+end_src
  

#  LocalWords:  Uniquify Iswitch
* ERC

  #+begin_src emacs-lisp
    (require 'erc-join)    
    (require 'erc-match)
    (setq erc-keywords '("darion" "kurohin"))
    
    ;; Exclude messages sent by the server when you join a channel, such as the nicklist and topic:
    (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                    "324" "329" "332" "333" "353" "477"))
    
    (defun jiha-erc-after-connect-hook (SERVER NICK))
    
    (add-hook 'erc-after-connect 'jiha-erc-after-connect-hook)
    
    (erc-autojoin-mode 1)
    (setq erc-autojoin-channels-alist
          ;; localhost should have a ssh tunnel to 85.238.219.29
          '(("localhost" "#emacs" "#org-mode" "#erc")
            ("oftc.net" "#BitlBee")))
    
    (defun irc-maybe ()
      "Connect to IRC."
      (interactive)
      (when (y-or-n-p "IRC? ")
        ;; should be a ssh tunnel to freenode
        (erc :server "localhost" :port 6667
             :nick "kurohin" :full-name "Jim Hansson")
        ;;(erc :server "irc.oftc.net" :port 6667
        ;;     :nick "kurohin" :full-name "Jim Hansson")
        ;; should be a ssh tunnel to testing.bitlbee.org
        (erc :server "localhost" :port 7000
             :nick "kurohin" :full-name "Jim Hansson")))
    
    ;; logging:
    (setq erc-log-insert-log-on-open nil)
    (setq erc-log-channels t)
    (setq erc-log-channels-directory "~/.irclogs/")
    (setq erc-save-buffer-on-part t)
    (setq erc-hide-timestamps nil)
    
    (defadvice save-buffers-kill-emacs (before save-logs (arg) activate)
      (save-some-buffers t (lambda () (when (and (eq major-mode 'erc-mode)
                                                 (not (null buffer-file-name)))))))
    
    (add-hook 'erc-insert-post-hook 'erc-save-buffer-in-logs)
    (add-hook 'erc-mode-hook '(lambda () (when (not (featurep 'xemacs))
                                           (set (make-variable-buffer-local
                                                 'coding-system-for-write)
                                                'emacs-mule))))
    ;; end logging
    
    ;; Truncate buffers so they don't hog core.
    (setq erc-max-buffer-size 20000)
    (defvar erc-insert-post-hook)
    (add-hook 'erc-insert-post-hook 'erc-truncate-buffer)
    (setq erc-truncate-buffer-on-save t)
    
    (erc-timestamp-mode t)
    (setq erc-timestamp-format "[%R-%m/%d]")
    
    (global-set-key (kbd "C-c I") 'reset-erc-track-mode)
    (setq erc-auto-query 'buffer)
    
  #+end_src

* BBDB

#+begin_src emacs-lisp
  (add-to-list 'load-path (concat local-emacs-org-dir "bbdb-2.35/lisp"))
  (require 'bbdb)
  (bbdb-initialize 'gnus 'message)
  (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
#+end_src

  other stuff i might need
  (provide 'bbdb-autoloads)
  (if
  (and load-file-name
  (file-name-directory load-file-name))
  (add-to-list 'load-path (file-name-directory load-file-name)))
