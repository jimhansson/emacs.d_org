# -*- mode: org -*-
#+TITLE: My emacs configuration
#+AUTHOR: Jim Hansson
#+EMAIL: jim.hansson@gmail.com
#+DATE: <2012-06-28 to>
#+LANGUAGE: English

This is my main .emacs file. It is responsible for calling out to the
local file at different points. This is placed in a git repository
that I share between work and home


* File setup
#+STARTUP: hidestars hideblocks
#+COLUMNS: %50ITEM %4TODO %20TAGS
#+LINK: norang http://doc.norang.ca/org-mode.html#
  
* Bugs
* Introduction
  Basic things that could have been down throu custom-set-variable but
  then I would have harder time to replicate that between machines.
  
*** Requirements

    - Emacs 24
    - a basic .emacs file that calls this after it inits org-babel 
    - a lot of extra packages. most configuration will check for it
      
*** Other important stuff
***** Only load things that exists.

      that can be done this way, use this to avoid errors on machine
      which don't have every package installed.

      #+begin_example
        (when (require 'deft nil 'noerror) 
      #+end_example

*** Setup
    
    Some user information
    #+begin_src emacs-lisp
      (setq user-full-name "Jim Hansson")
      (setq user-mail-address "jim.hansson@powel.se")   
    #+end_src

    Here we setup some basic things, I dont like the toolbar so that we
    turn off, I use OrgMode to almost everything(even my .emacs) so
    that will be my default mode. Almost all computers I use are
    laptops and who in there right mind uses 12h clocks.

    #+begin_src emacs-lisp
      (tool-bar-mode -1)
      (setq default-major-mode 'org-mode)
      (add-hook 'text-mode-hook 'turn-on-auto-fill)
      ;; show matching paren
      (show-paren-mode t)
      (iswitchb-mode 1)
      (setq filesets-data nil)
      (display-battery-mode)
      (global-font-lock-mode t)
      ;; binds ctrl + § to dabbrev as good enough completion 
      (global-set-key (kbd "C-\§") 'dabbrev-expand)
      (setq-default indent-tabs-mode t)
    #+end_src

*** Modeline                                                       :modeline:
    
    #+begin_src emacs-lisp
      ;; Things that modifies the modeline
      (setq display-battery-mode t)
      (setq display-time-24hr-format t)
      ;; I work width some really big files and then it is good to have this
      ;; so i know how far down I am.
      (setq size-indication-mode t)
    #+end_src
    
*** Whitespace

    I use whitespace mode a lot, maybe because I dont have configured
    the programming modes to "do the right thing" yet and some other
    programmers around me are experts at leaving trailing whitespaces
    and mixing tabs and spaces. <rant>the same persons ussally write
    really long lines to, and have 8 levels of indentation in the same
    method and uses indent depth of 4 or 8, I wonder how wide their
    screen is.</rant>

    #+begin_src emacs-lisp
      ;; whitespace-mode things
      
      ;; less color in whitespace mode, The yellow and red is to distracting
      (setq whitespace-style (quote (spaces tabs newline space-mark 
                                            tab-mark newline-mark)))
      
      ;; make whitespace-mode use "" for newline and -> for tab.
      ;; together with the rest of its defaults
      (setq whitespace-display-mappings
            '(
              (space-mark 32 [183] [46]) ; normal space, ·
              (space-mark 160 [164] [95])
              (space-mark 2208 [2212] [95])
              (space-mark 2336 [2340] [95])
              (space-mark 3616 [3620] [95])
              (space-mark 3872 [3876] [95])
              (newline-mark 10 [8629 10]) ; newlne
              (tab-mark 9 [8677 9] [92 9]) ; tab
              ))
      
      ;; My own whitespace cleanup function should be bound to something.
      ;; or used in some save-hook don't know how this work together with smart-tabs
      (defun jiha-whitespace-cleanup ()
        (interactive)
        (let (whitespace-style (indentation::tab 
                                space-before-tab::tab
                                trailing))
          (whitespace-cleanup-region)))
    #+end_src
*** Uniquify                                               :uniquify:buffers:

    Better naming of buffers so we can easly tell the differens between
    buffers. Have some problem together with Iswitch

    #+begin_src emacs-lisp
      (require 'uniquify)
      (setq uniquify-buffer-name-style (quote post-forward))
    #+end_src

*** Disable warnings for first time users
    
    For some reason some questions in emacs are yes/no and some are y/n
    this trips me sometimes so we turn that off, and the same goes for
    killing emacs. We also removes some questions that are asked to
    make sure that the users really wants what is going to happen, I
    know how to use undo and else I usually have some version control
    system running so I can go back.

    #+begin_src emacs-lisp
      ;; Changes all yes/no questions to y/n type
      (fset 'yes-or-no-p 'y-or-n-p)
      (set-variable 'confirm-kill-emacs 'yes-or-no-p)
      ;; more of these as I find them
      (put 'narrow-to-region 'disabled nil)
      (setq safe-local-variable-values (quote ((auto-fill-mode . t))))
    #+end_src

* Requirements from elpa
  First setup package archives
  #+begin_src emacs-lisp
    ; Setup package archives
    (setq package-archives ())
    (add-to-list 'package-archives '("ELPA" . "http://tromey.com/elpa/"))
    (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
    ; http://marmalade-repo.org/ 
    (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
    
  #+end_src

  Then use M-x list-packages to find and install these packages.
  - oauth2 :: for google integration
              for some reason I need to add oauth directory to
              load-path, should not elpa take care of that.

* Auto complete

  #+begin_src emacs-lisp
    (add-to-list 'load-path (concat local-emacs-org-dir 
                                    "auto-complete"))
    (require 'auto-complete-config)
    (add-to-list 'ac-dictionary-directories (concat local-emacs-org-dir 
                                                    "ac-dicts"))
    (ac-config-default)
    ;;(define-key ac-mode-map (kbd "M-TAB") 'auto-complete)
    (ac-flyspell-workaround)
  #+end_src

* Some Basic faces                                                    :faces:

  I use the possiblity that a face can inherit from one, or more faces
  to setup faces along a few different axis.
  #+begin_src emacs-lisp

    (defgroup jiha-faces nil "Configuration for faces")
    ; expirment
    ; defines the basic faces used to for indicating how important thing is
    (defface jiha-need-attention-face 
      '((t (:foreground "Red")))
      "Some text"
      :group 'jiha-faces)
    
    (defface jiha-notice-me-face      
      '((t (:foreground "salmon")))
      "Some text"
      :group 'jiha-faces)
    
    (defface jiha-warning-face 
      '((t (:foreground "Orange")))
      "Some text"
      :group 'jiha-faces)
    
    (defface jiha-good-thing-face
      '((t (:foreground "Green")))
      "Some Text"
      :group 'jiha-faces)
    
    ; Face to tell that it should not be changed or can not be changed
    (defface jiha-donotwrite-face
      '((t (:foreground "Red")))
      "Some Text"
      :group 'jiha-faces)
    
    ; Things that dont really exist, or not a file
    (defface jiha-not-real-face 
      '((t (:slant italic :group jiha-faces)))
      "Some Text"
      :group 'jiha-faces)
    
  #+end_src

* Iswitch Buffers                                                   :buffers:

  To prevent certain buffers from showing up in the completion list,
  set 'iswitchb-buffer-ignore': (setq iswitchb-buffer-ignore '("^ "
  "*Buffer")) This one is useful if you want to lose the *...*
  special buffers from the list. It's helpful if you're using the
  JDEE for editing Java apps, as you end up with buffers named
  org.whatever.package.Class which you might want to eliminate: (setq
  iswitchb-buffer-ignore '("^\\*")) To prevent switching to another
  frame, you can add the following to your configuration: (setq
  iswitchb-default-method 'samewindow)

  #+begin_src emacs-lisp
    (iswitchb-mode 1)
    ;; rebind the normal key for buffer list to ibuffer
    (global-set-key (kbd "C-x C-b") 'ibuffer)
    (setq ibuffer-expert t)
    (setq ibuffer-show-empty-filter-groups nil)
    (setq iswitchb-default-method 'samewindow)
    ;; in your .emacs will allow left/right artist--arrow key navigation of the
    ;; buffer list, and deactivate up/down in iswitchb. Note that you
    ;; can by default use C-s and C-r to do this.  If the
    ;; below fails with "define-key: Symbol's function definition is
    ;; void: edmacro-parse-keys" you need to load the package defining
    ;; edmacro with (require 'edmacro).
    (defun iswitchb-local-keys ()
      (mapc (lambda (K) 
              (let* ((key (car K)) (fun (cdr K)))
                (define-key iswitchb-mode-map (edmacro-parse-keys key) fun)))
            '(("<right>" . iswitchb-next-match)
              ("<left>"  . iswitchb-prev-match)
              ("<up>"    . ignore             )
              ("<down>"  . ignore             ))))
    (add-hook 'iswitchb-define-mode-map-hook 'iswitchb-local-keys)
  #+end_src
  
  #+begin_src emacs-lisp
    (setq ibuffer-saved-filter-groups
          '(("home"
             ("Emacs" (or (filename . ".emacs.d")
                          (filename . "emacs.org")
                          (filename . ".emacs")))
             ("Org" (or (filename . ".org")
                        (filename . "OrgMode")
                        (name . "*Org Agenda*")
                        (name . "diary")))
             ("code" (or (mode . csharp-mode)
                         (mode . c++-mode)
                         (mode . lisp-mode)))
             ("Web Dev" (or (mode . html-mode)
                            (mode . css-mode)))
             ("SQL" (or (filename . ".plb")
                        (filename . ".sql")
                        (mode . sqli-mode)
                        (name . "*SQL*")))
             ("VC" (or (name . "\*svn")
                       (name . "\*magit")))
             ("ERC" (or (mode . erc-mode)
                        (mode . erc-list-mode)))
             ("gnus" (or
                      (mode . message-mode)
                      (mode . bbdb-mode)
                      (mode . mail-mode)
                      (mode . gnus-group-mode)
                      (mode . gnus-summary-mode)
                      (mode . gnus-article-mode)
                      (name . "^\\.bbdb$")
                      (name . "^\\.newsrc-dribble")))
             ("Help" (or (name . "\*Help\*")
                         (name . "\*Apropos\*")
                         (name . "\*info\*"))))))
   #+end_src

   #+begin_src emacs-lisp
        (add-hook 'ibuffer-mode-hook 
                  '(lambda ()
                     (ibuffer-auto-mode 1)
                     (ibuffer-switch-to-saved-filter-groups "home")))
        
        ;; Switching to ibuffer puts the cursor on the most recent buffer
        (defadvice ibuffer (around ibuffer-point-to-most-recent) ()
          "Open ibuffer with cursor pointed to most recent buffer name"
          (let ((recent-buffer-name (buffer-name)))
            ad-do-it
            (ibuffer-jump-to-buffer recent-buffer-name)))
        (ad-activate 'ibuffer)
        
        
        (setq ibuffer-formats
              '((mark modified read-only " "
                      (name 25 25 :left :elide) " "
                      (size 9 -1 :right) " "
                      (mode 16 16 :left :elide) " " filename-and-process)
                (mark " " (name 16 -1) " " filename)))
    
     
    (defun switch-buffers-between-frames ()
      "switch-buffers-between-frames switches the buffers between the two last frames"
      (interactive)
      (let ((this-frame-buffer nil)
            (other-frame-buffer nil))
        (setq this-frame-buffer (car (frame-parameter nil 'buffer-list)))
        (other-frame 1)
        (setq other-frame-buffer (car (frame-parameter nil 'buffer-list)))
        (switch-to-buffer this-frame-buffer)
        (other-frame 1)
        (switch-to-buffer other-frame-buffer))) 
  #+end_src

*** Colours in buffer list                                            :faces:

    #+begin_src emacs-lisp
      ; coloring
        
      ; these are the the standard faces used but with new names so we can
      ; change them in a simple way.
      (defface jiha-ibuffer-readonly-face 
        '((t (:inherit  (jiha-donotwrite-face font-lock-constant-face))))
        "Some Text"
        :group 'jiha-faces)
      (defface jiha-ibuffer-compressed-file-name-regex-face 
        '((t (:inherit font-lock-doc-face)))
        "Some Text"
        :group 'jiha-faces)
      (defface jiha-ibuffer-dired-mode-face 
        '((t (:inherit font-lock-function-name-face)))
        "Some Text"
        :group 'jiha-faces)
      (defface jiha-ibuffer-help-modes-face 
        '((t (:inherit font-lock-comment-face)))
        "Some Text"
        :group 'jiha-faces)
      (defface jiha-ibuffer-some-weird-face 
        '((t (:slant italic)))
        "Some Text"
        :group 'jiha-faces)
      
      ; format of the list is priority, condition, face
      ; highest priority wins
      ;;(setq 'ibuffer-fontification-alist
      ;;      '(10 (Form)
      ;;           (face)))                 
      
    #+end_src
*** Iswitch and uniquify compatibility                              :uniquify:

    The library uniquify overrides Emacs default mechanism for making
    buffer names unique (using suffixes like <2>, <3> etc.) with a
    more sensible behaviour which use parts of the file names to make
    the buffer names distinguishable.  Additionally one can configure
    uniquify to rework the buffer names whenever a buffer is
    killed. This feature does not play well with IswitchBuffers
    function iswitchb-kill-buffer, bound to C-k. The following code
    instructs iswitchb-kill-buffer to update the buffer list after
    killing a buffer, so that a possible buffer renaming by uniquify
    is taken in account.

    #+begin_src emacs-lisp
      (defadvice iswitchb-kill-buffer (after rescan-after-kill activate)
        "*Regenerate the list of matching buffer names after a kill.
      Nextcessary if using `uniquify' with `uniquify-after-kill-buffer-p'
      set to non-nil."
        (setq iswitchb-buflist iswitchb-matches)
        (iswitchb-rescan))
      
      (defun iswitchb-rescan ()
        "*Regenerate the list of matching buffer names."
        (interactive)
        (iswitchb-make-buflist iswitchb-default)
        (setq iswitchb-rescan t))
    #+end_src

*** More Iswitch things that I don't use at the moment
    http://martinowen.net/blog/2010/02/tips-for-emacs-ibuffer.html
***** Keybindings

      Something most IswitchBuffers users aren't aware of is that you
      can hit C-k to kill the currently selected buffer.

***** Using Iswitch-Buffer Programmatically
      
      From: KinCho
      Subject: my-icompleting-read
      Newsgroups: gnu.emacs.sources
      Date: Tue, 09 Oct 2001 16:28:18 GMT
      
      I used iswitchb for a while and really liked it. I began to
      explore to see if I can borrow iswitchb to make my scripts work
      like iswitchb as well. Well, it turned out iswitchb is coded in a
      way that makdes it really easy to borrow it to do regex-style
      completing-read: 

      #+begin_example emacs-lisp
      (defun my-icompleting-read(prompt choices)
      (let ((iswitchb-make-buflist-hook
      (lambda ()
      (setq iswitchb-temp-buflist choices))))
      (iswitchb-read-buffer prompt)))
      #+end_example

      Another example. Two things. "nil t" to iswitchb-read-buffer
      requires a choice from the given list with no default. Using an
      flet is a way to work when there's no hook variable. There is a
      hook variable. 

      #+begin_example emacs-lisp
      (defvar interesting  (regexp-opt '(".c" ".h" "etc.")))
      (defvar some-directory "/home/somewhere/etc/")

      ;; Making this more flexible is an exercise for the reader
      (defun find-a-file (arg &optional non-selective)
      "Select files using substrings."
      (interactive "sFile: ")
      (let ((dir (expand-file-name some-directory))
      candidates)
      (flet ((file-match (file)
      (if non-selective
      (string-match arg file)
      (and
      (string-match interesting file)
      (string-match arg file)))))
      (setq candidates (delq nil (loop for file in (directory-files dir)
      collect (if (file-match file) file)))))
      (cond
      ((eq (length candidates) 1)
      (find-file (format "%s%s" dir (car candidates))))
      ((eq (length candidates) 0)
      (if non-selective
      (message "No such file!")
      (find-a-file arg t)))
        (t
        (flet ((iswitchb-make-buflist (default)
        (setq iswitchb-buflist candidates)))
        (find-file (format 
        "%s%s" dir
        (iswitchb-read-buffer "File: " nil t))))))))
      #+end_example
        
      I'm quite new to iswitchb. I've been after eliminating the need to
      confirm (with TAB or ret) the last left possibility. 
        
      I've started with this simple hack, which only displays the
      desired buffer, but in this way, i don't need to look at the
      minibuffer (in some cases). 
      
      #+begin_example emacs-lisp
      (defun iswitchb-post-command ()
      "Run after command in 'iswitchb-buffer'."
      (iswitchb-exhibit)
      (if (= (length iswitchb-matches) 1)
      (display-buffer (car iswitchb-matches))))
      #+end_example
      
      another thing i like, is to have the freedom to decide to open the
      buffer in other-window/frame after i made the selection: Hence a
      new minibuffer exiting command: 
      
      #+begin_example emacs-lisp
      (defun iswitchb-select-buffer-other-window ()
      "Select the buffer named by the prompt. But in another window."
      (interactive)
      (setq iswitchb-method 'otherwindow)
      (exit-minibuffer))
      #+end_example
      
      The functionality of iswitchb can also be used to provide a
      replacement for the usual behaviour of find-file. Instead of
      hitting Tab to bring up a buffer listing the possible file
      completions, a list of file completions is continuously updated in
      the minibuffer: 
      
      #+begin_example emacs-lisp
      (defun exd-find-file ()
      "Use functionality from `iswitchb' as a replacement for `find-file'"
      (interactive)
      (find-file (exd-iswitchb-find-file "." (directory-files "."))))
      
      (defun exd-iswitchb-find-file (dir file-list)
      "Use functionality from `iswitchb' to select a file for `find-file'.
      If a directory is selected, enter that directory and generate a new
      list from which to select a file."
      ;; sort the file list into directories first
      (setq file-list
      (sort file-list
      (lambda (elt-1 elt-2)
      (and (file-directory-p (concat dir "/" elt-1))
      (not (file-directory-p (concat dir "/" elt-2)))))))
      ;; use iswitchb for minibuffer file list/completion magic
      (let* (resize-mini-windows
      (iswitchb-make-buflist-hook
      (lambda ()
      (setq iswitchb-temp-buflist file-list)))
      ;; get the selected file
      (selected-file (concat dir "/" (iswitchb-read-buffer
      (concat "Find File: "
      (expand-file-name dir)
      "/")))))
      ;; if the selected file is a directory, recurse, else return file
      (if (file-directory-p selected-file)
      (exd-iswitchb-find-file selected-file (directory-files selected-file))
      selected-file)))
      #+end_example
      
      See Also:
      
      Icicles, and command 'icicle-buffer', which is similar to
      'iswitchb-buffer' but provides some additional features. Also,
      Icicles treats all types of minibuffer input the same way:
      filenames, buffer names, commands, variables...everything. And it
      lets you use a regexp to match completions, if you like. 
      InteractivelyDoThings (ido), which implements regex selection for
      files, directory buffers etc...

* Buffer Menu
*** TODO Font lock                                                 :fontlock:

    If you use ElectricBufferList, then simply use this instead for the
    last line:
    (add-hook 'electric-buffer-menu-mode-hook 'buffer-menu-custom-font-lock)
    
    need to put the right colors on this.
    #+begin_src emacs-lisp
      (setq buffer-menu-buffer-font-lock-keywords
            '(("^....[*]Man .*Man.*"   . font-lock-variable-name-face) ;Man page
              (".*Dired.*"             . font-lock-comment-face)       ; Dired
              ("^....[*]shell.*"       . font-lock-preprocessor-face)  ; shell buff
              (".*[*]scratch[*].*"     . font-lock-function-name-face) ; scratch buffer
              ("^....[*].*"            . font-lock-string-face)        ; "*" named buffers
              ("^..[*].*"              . font-lock-constant-face)      ; Modified
              ("^.[%].*"               . font-lock-keyword-face)))     ; Read only
      
      (defun buffer-menu-custom-font-lock  ()
        (let ((font-lock-unfontify-region-function
               (lambda (start end)
                 (remove-text-properties start end '(font-lock-face nil)))))
          (font-lock-unfontify-buffer)
          (set (make-local-variable 'font-lock-defaults)
               '(buffer-menu-buffer-font-lock-keywords t))
          (font-lock-fontify-buffer)))
      
      (add-hook 'buffer-menu-mode-hook 'buffer-menu-custom-font-lock)
     #+end_src

* TODO Coding

  Here I will place everything that has todo with coding

*** Flymake
***** Flymake Cursor

      The normal operation of flymake allows the user to see the error
      message for a particular line by “hovering” the mouse over the
      line. This is inconvenient for people who try to use the keyboard
      for all input. FlymakeCursor was designed to address that: it
      displays the flymake error in the minibuffer region, when the
      cursor is placed on a line containing a flymake error. 

      This works in any language that flymake supports

      #+begin_src emacs-lisp
        (load-file (concat local-emacs-org-dir "flymake-cursor.el"))
      #+end_src
*** Compile  
*** TODO Coding styles
    :LOGBOOK:
    :END:
    check out [[http://emacswiki.org/emacs/IndentingC#toc2][emacswiki on indenting]]
***** Microsoft C & C++ style

      Here is a style that pretty much matches the observed style of
      Microsoft (R)'s C and C++ code.

      #+begin_src emacs-lisp
        (c-add-style "microsoft"
                     '("stroustrup"
                       (c-offsets-alist
                        (innamespace . -)
                        (inline-open . 0)
                        (inher-cont . c-lineup-multi-inher)
                        (arglist-cont-nonempty . +)
                        (template-args-cont . +))))
        
      #+end_src

***** OpenBSD style

      Style for OpenBSD? source code, also valid for OpenSSH? and other
      BSD based OSs source.

      #+begin_src emacs-lisp
        (c-add-style "openbsd"
                     '("bsd"
                       (indent-tabs-mode . t)
                       (defun-block-intro . 8)
                       (statement-block-intro . 8)
                       (statement-case-intro . 8)
                       (substatement-open . 4)
                       (substatement . 8)
                       (arglist-cont-nonempty . 4)
                       (inclass . 8)
                       (knr-argdecl-intro . 8)))
      #+end_src
***** Google C++ Style

      This is the C++ style that I personaly finds to be best.

      #+begin_src emacs-lisp
        (require 'google-c-style nil 'noerror)
      #+end_src

*** Visual Studio Integration

    Integration with VS, We have aseperate file with commands to tell
    visual studio to do things. at the moment we only have to commands
    but it should be simple to extend it with others.

    #+begin_src emacs-lisp
      ;; only on windows to save startup-time
      (if (eq system-type 'windows-nt)
          '((org-babel-load-file (concat local-emacs-org-dir "devenv-tricks.org"))
           ;; Now in those mode where it might be useful do something like
           ;; (global-set-key [f9] 'devenv-toggle-breakpoint)
           ;; (global-set-key [f5] 'devenv-debug)
          (global-set-key [f3] 'devenv-switch-to-devenv)))
    #+end_src

*** TODO CEDET

    Use a local installation of CEDET so we have control over what
    version we use. This means that we should not use any version from
    ELPA or local package system.

    #+begin_src emacs-lisp
      (require 'edmacro)
      ;; using my own
      (load-file (concat local-emacs-org-dir "cedet-1.1/common/cedet.el"))
      (global-ede-mode t)                      ; Enable the Project management system
      (semantic-load-enable-code-helpers)      ; Enable prototype help and smart completion 
      (global-srecode-minor-mode 1)
    #+end_src
    
    #+begin_src emacs-lisp
    ;;  (require 'semantic)
    #+end_src

***** TODO change this to be a submodule instead
***** EDE
      #+begin_src emacs-lisp
      ;;  (global-ede-mode t)
      #+end_src

***** Code helpers

      #+begin_src emacs-lisp
      ;;  (semantic-load-enable-excessive-code-helpers)
      #+end_src

*** TODO Completion
***** Language
******* C#
        
        #+begin_src emacs-lisp
          (add-to-list 'load-path (concat local-emacs-org-dir "csharp"))
        #+end_src

        The `cscomp-assembly-search-paths' should hold a list of
        directories to search for assemblies that get referenced via using
        clauses in the modules you edit.  This will try default to
        something reasonable, including the "typical" .NET 2.0 and 3.5
        directories, as well as the default locations for reference
        assemblies.  If you have non-default locations for these things,
        you should set them here. Also, if you have other libraries (for
        example, the WCF Rest Starter kit, or the Windows Automation
        assemblies) that you reference within your code, you can include
        the appropriate directory in this list.
       
        #+begin_example emacs-lisp
         (eval-after-load "csharp-completion"
          '(progn
             (setq cscomp-assembly-search-paths
               (list "c:\\.net3.5ra"    ;; <<- locations of reference assemblies
                     "c:\\.net3.0ra"    ;; <<-
                     "c:\\.net2.0"      ;; <<- location of .NET Framework assemblies
                     "c:\\.net3.5"      ;; <<- ditto
             ))))
        #+end_example

        #+begin_src emacs-lisp
           ;; only on windows do we use csharp completion.
          
          (when (require 'powershell nil 'noerror)
            (when (require 'csharp-completion nil 'noerror) 
              (defun jiha-csharp-mode-hook  
                ;; C# code completion
                (load-file (concat local-emacs-org-dir "csharp/csharp-completion.el"))
                ;;(csharp-analysis-mode 1)
                ;;(local-set-key "\M-\\"   'cscomp-complete-at-point)
                ;;(local-set-key "\M-§."   'cscomp-complete-at-point-menu)
                )
            
              (add-to-list 'csharp-mode-hook
                           'jiha-csharp-mode-hook))
          )
          
        #+end_src
*** Indentation

    I usually use tabs for indentation and spaces for alignment, Emacs
    are one of the few eviroment that support that kind of thing. I
    like a low c-basic-offset 2

    #+begin_src emacs-lisp
      ;; use tabs for indentation later we setup spaces for alignment.
      (setq-default indent-tabs-mode t)
      ;; I want as much as possible on my screens.
      (setq-default c-basic-offset 2)
      (setq-default tab-width 2) ; or any other preferred value
    #+end_src
    
    #+begin_src emacs-lisp
      ;; smart tabs, tabs for indentation, spaces for alignment
      (defadvice align (around smart-tabs activate)
        (let ((indent-tabs-mode nil)) ad-do-it))
      
      (defadvice align-regexp (around smart-tabs activate)
        (let ((indent-tabs-mode nil)) ad-do-it))
      
      (defadvice indent-relative (around smart-tabs activate)
        (let ((indent-tabs-mode nil)) ad-do-it))
      
      (defadvice indent-according-to-mode (around smart-tabs activate)
        (let ((indent-tabs-mode indent-tabs-mode))
          (if (memq indent-line-function
                    '(indent-relative
                      indent-relative-maybe))
              (setq indent-tabs-mode nil))
          ad-do-it))
      
      (defmacro smart-tabs-advice (function offset)
        `(progn
           (defvaralias ',offset 'tab-width)
           (defadvice ,function (around smart-tabs activate)
             (cond
              (indent-tabs-mode
               (save-excursion
                 (beginning-of-line)
                 (while (looking-at "\t*\\( +\\)\t+")
                   (replace-match "" nil nil nil 1)))
               (setq tab-width tab-width)
               (let ((tab-width fill-column)
                     (,offset fill-column)
                     (wstart (window-start)))
                 (unwind-protect
                     (progn ad-do-it)
                   (set-window-start (selected-window) wstart))))
              (t
               ad-do-it)))))
      
      (smart-tabs-advice c-indent-line c-basic-offset)
      (smart-tabs-advice c-indent-region c-basic-offset)
      ;; smart tabs - end
    #+end_src

***** SQL

      #+begin_src emacs-lisp
       (eval-after-load "sql"
         '(load-library "sql-indent"))
      #+end_src
      
* Fly-spell

  My spelling is terrible so we use fly-spell as much as possible when
  it is available. We turn it on for most text-modes and
  flyspell-prog-mode for programming. 

  I highly suggest setting ‘flyspell-issue-message-flag’ to nil, as
  printing messages for every word (when checking the entire buffer)
  causes an enormous slowdown. 

  deactivated on windows at the moment until we have fixed cygwin
  ispell or Aspell.
  #+begin_src emacs-lisp
    (if (eq system-type 'linux)
        ((when (require 'flyspell nil 'noerror)
           ;; activate flyspell for text-mode and derivatives
           (dolist (hook '(text-mode-hook))
             (add-hook hook (lambda () (flyspell-mode 1))))
           ;; this is how we remove it for a sub-mode
           ;;(dolist (hook '(change-log-mode-hook log-edit-mode-hook))
           ;;  (add-hook hook (lambda () (flyspell-mode -1))))
           )
        
         (setq flyspell-issue-message-flag nil))
      )
  #+end_src
  
*** Fly-spell for comments when programming                          :coding:

    #+begin_src emacs-lisp
      ;; Flyspell in C based programming modes
      (add-hook 'c-mode-hook
                (lambda ()
                  (flyspell-prog-mode)))
      
      ;; Flyspell in C++ based programming modes
      (add-hook 'c++-mode-hook
                (lambda ()
                  (flyspell-prog-mode)))
      
      ;; Flyspell in emacs-lisp mode
      (add-hook 'lisp-mode-hook
                (lambda ()
                  (flyspell-prog-mode)))
    #+end_src

*** TODO word-list for org-files.
    
    org-files contains some reserved words like #+begin_* ... these
    should be included in some sort of wordlist we use. so we don't get
    a lot of errors on those files.

*** TODO don't use flyspell in src samples
    
    Or switch to flyspell-prog-mode somehow.

*** TODO Avoid false positives

    I recently started using flyspell and am enjoying its features. Is
    there a way to disable flyspell for certain regexps? For instance,
    I would like to disable flyspell when typing a url. Otherwise, when
    entering a url such as
    http://www.emacswiki.org/cgi-bin/emacs/FlySpell, www, emacswiki,
    cgi and FlySpell are highlighted as errors. Any advice would be
    greatly appreciated. – MattLundin 

    There is only one way, using flyspell-generic-check-word-predicate
    which should be a function. In such a function you can use thing at
    point. 

    However it is a bit difficult to manage this as this variable may
    be only one function. I have submitted a patch to Emacs devel to
    take care of this. 

    Thanks for pointing me to the flyspell-generic-check-word-predicate
    variable. – MattLundin

*** TODO Windows
    
    we need to install cygwin and use aspell.
    http://curiousprogrammer.wordpress.com/2009/04/25/flyspell-windows/

*** TODO somehow use #+LANGUAGE in org to choose wordlist.
*** Other flyspell things
***** Change dictionaries

    As I often need to switch between English and German I use this
    function:

    #+begin_example emacs-lisp
      (defun fd-switch-dictionary()
      (interactive)
      (let* ((dic ispell-current-dictionary)
    	 (change (if (string= dic "deutsch8") "english" "deutsch8")))
        (ispell-change-dictionary change)
        (message "Dictionary switched from %s to %s" dic change)
        ))
    
      (global-set-key (kbd "<f8>")   'fd-switch-dictionary)
    #+end_example

    I too cycle through different languages, but not all that is
    available in the system. I use the following code inside my
    .emacs. 

    #+begin_example emacs-lisp
    (let ((langs '("american" "francais" "brasileiro")))
      (setq lang-ring (make-ring (length langs)))
      (dolist (elem langs) (ring-insert lang-ring elem)))

    (defun cycle-ispell-languages ()
      (interactive)
      (let ((lang (ring-ref lang-ring -1)))
        (ring-insert lang-ring lang)
        (ispell-change-dictionary lang)))

    (global-set-key [f6] 'cycle-ispell-languages)
    #+end_example

    How can I ignore or add a word without using the popup menu?

    Use flyspell-auto-correct-word.

    This is not working for me. With flyspell-auto-correct-word I can
    go through all suggestions for correction, but I do not get an
    option to insert the word into my dictionary. Success in adding
    new words into the personal dictionary.

    I used “M x ispell-region”, and the words that ispell considered
    having incorrect spellings were highlighted. The point moved to
    the first “mis-spelled” word. By typing “i”, I inserted the word
    into my personal dictionary. Later I found that the personal
    dictionary was stored in the file $HOME/.aspell.en.pws in pure
    text format. Although the word was added when I used “ispell”
    instead of “flyspell”, but once added, flyspell also recognized
    the word as having a correct spelling. :-) This information came
    from the web page:
    http://www.delorie.com/gnu/docs/emacs/emacs_109.html . Thanks! 

    Easy Spell Check: key bindings and function to make
    FlySpell/ispell/aspell easy to use w/ out a mouse 

    Place the below code in your .emacs

    F8 will call ispell (or aspell, etc) for the word the cursor is on
    (or near). You can also use the built-in key binding
    M-$. Ctrl-Shift-F8 enables/disables FlySpell for your current
    buffer (highlights misspelled words as you type) Crtl-Meta-F8 runs
    FlySpell on your current buffer (highlights all misspelled words
    in the buffer) Ctrl-F8 calls ispell for the FlySpell highlighted
    word prior to the cursor’s position Meta-F8 calls ispell for the
    FlySpell highlighted word after the cursor’s position.

    #+begin_example emacs-lisp
      ;; easy spell check
      (global-set-key (kbd "<f8>") 'ispell-word)
      (global-set-key (kbd "C-S-<f8>") 'flyspell-mode)
      (global-set-key (kbd "C-M-<f8>") 'flyspell-buffer)
      (global-set-key (kbd "C-<f8>") 'flyspell-check-previous-highlighted-word)
      (defun flyspell-check-next-highlighted-word ()
        "Custom function to spell check next highlighted word"
        (interactive)
        (flyspell-goto-next-error)
        (ispell-word)
        )
      (global-set-key (kbd "M-<f8>") 'flyspell-check-next-highlighted-word)
#+end_example

* OrgMode
*** TODO Rework 

    this to support more that 2 different org directories and to not
    make a difference bewtween them as much as possible.

     (setq org-directory "~/Dokument/orgfiles/")
     (setq org-default-notes-file "~/.notes")

*** Basic

    #+begin_src emacs-lisp
      ;; do not have so much in my agenda so two weeks is good
      (setq org-agenda-ndays 14)
      (setq org-deadline-warning-days 14)
      (setq org-timeline-show-empty-dates t)
      (setq org-agenda-repeating-timestamp-show-all nil)
      (setq org-agenda-include-diary t)
      (setq org-feed-alist)
      (setq org-odd-levels-only t)
      (setq org-cycle-separator-lines 0)
      (setq org-use-fast-todo-selection t)
      (setq org-treat-S-cursor-todo-selection-as-state-change nil)
      (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
      (setq org-insert-mode-line-in-empty-file t)
      ;; setup automatic expiring of old entries with creation date
      ;; if entries does not have creation date they will never expire.
      (load-file (concat local-emacs-org-dir "org-modules/org-expiry.el"))
      (setq org-expiry-wait "+2m")
      ;;(org-expiry-insinuate)
      (load-file (concat local-emacs-org-dir "org-modules/org-toc.el"))
      (require 'org-crypt)
      (org-crypt-use-before-save-magic)
      (setq org-tags-exclude-from-inheritance (quote ("crypt")))
      (run-at-time "00:59" 3600 'org-save-all-org-buffers)
    #+end_src
    
    A large part of the configuration has to do with how org should
    behave. it's a pretty complex mode with lot of things you could
    change. I have tried to make it as simple a possible with sub-trees
    for every main function of OrgMode.
    
***** TODO setup what org-modules we should have

      at the moment this is done on by customize and that means we need
      to do it on every machine.
      
*** RSS feeds

    #+begin_src emacs-lisp
      (let ((feedfile (format "%s/%s" shared-org-files-dir "feeds.org")))
        (setq org-feed-alist
              `(("Slashdot"
                 "http://rss.slashdot.org/Slashdot/slashdotatom"
                 ,feedfile
                 "Slashdot")
                ("Bruce"
                 "http://feeds.feedburner.com/schneier/fulltext"
                 ,feedfile
                 "Bruce Schneier On Security")
                ("PiratPartiet"
                 "http://live.piratpartiet.se/rss20.xml"
                 ,feedfile
                 "PiratPartiet SE"))))
    #+end_src

*** Org todo keyword faces                                            :faces:
    All kewords are should be bold, that tells me they are keywords
    #+begin_src emacs-lisp
      ;; All keywords should be in bold so it's easy to se them as keywords
      (defface jiha-org-keywords-face 
        '((t (:inherit default :weight extra-bold)))
        "some String"
        :group 'jiha-faces)
      
      (defface jiha-org-todo-keywords-face
        '((t (:inherit (jiha-need-attention-face
                        jiha-org-keywords-face))))
        "Some Text"
        :group 'jiha-faces)
      (defface jiha-org-done-keywords-face
        '((t (:inherit (jiha-good-thing-face 
                        jiha-org-keywords-face))))
        "Some Text"
        :group 'jiha-faces)
      
      (defface jiha-org-onhold-keywords-face
        '((t (:inherit (jiha-notice-me-face
                        jiha-org-keywords-face))))
        "Some Text"
        :group 'jiha-faces)
      
      (defface jiha-org-not-important-keywords-face
        '((t (:inherit (jiha-not-real-face
                        jiha-good-thing-face
                        jiha-org-keywords-face))))
        "Some Text"
        :group 'jiha-faces)
    #+end_src
*** standard Todo states and transitions
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2012-08-20 må 17:19]
    :END:

    This is from [[norang:TodoKeywords]] it's proberbly more than I need.
    #+begin_src emacs-lisp
      (setq org-todo-keywords
            (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d@/@)")
                    (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE")
                    (sequence "INVESTIGATE(i@/!)" "BUG(b@/!)" "|" "NOT_A_BUG(!)" "FIXED(f@/@)"))))
      
      (setq org-todo-keyword-faces
            (quote (("TODO"      . jiha-org-todo-keywords-face)
                    ("NEXT" :foreground "light blue" :weight bold)
                    ("DONE"      . jiha-org-done-keywords-face)
                    ("WAITING"   . jiha-org-onhold-keywords-face)
                    ("HOLD"      . jiha-org-onhold-keywords-face)
                    ("CANCELLED" . jiha-org-not-important-keywords-face)
                    ("PHONE"     . jiha-org-not-important-keywords-face))))
       
    #+end_src
*** Init

    because I have more than one computer and also a work computer, I
    have split my org agenda files into two parts. One that I share
    between computers and one that is local to that machine(or
    filesystem I am working in). To Make configuration of org-agenda
    work with this I have files that I call in my shared org directory
    and in my local directory. So here is the first call.

    #+begin_src emacs-lisp
      (org-babel-load-file (concat local-org-files-dir "init.org"))
      (org-babel-load-file (concat shared-org-files-dir "init.org"))
    #+end_src
    
*** Auto Archiving of done entries

    Would be nice if we could auto archive things that have been done
    for 1 month or something similier. does not work at the moment need
    to find out why it hangs.

    #+begin_example emacs-lisp
      ; found on the emacs-orgmode mailing list.
      ; helping aboudreault with finding errors in it.
      (defvar org-my-archive-expiry-days 2
        "The number of days after which a completed task should be auto-archived.
      This can be 0 for immediate, or a floating point value.")
      
      (defun org-my-archive-done-tasks ()
        (interactive)
        (save-excursion
          (goto-char (point-min))
          (let ((done-regexp
                 (concat "\\* \\(" (regexp-opt org-done-keywords) "\\) "))
                (state-regexp
                 (concat "- State \"\\(" (regexp-opt org-done-keywords)
                         "\\)\"\\s-*\\[\\([^]\n]+\\)\\]")))
            (while (re-search-forward done-regexp nil t)
              (let ((end (save-excursion
                           (outline-next-heading)
                           (point)))
                    begin)
                (goto-char (line-beginning-position))
                (setq begin (point))
                (when (re-search-forward state-regexp end t)
                  (let* ((time-string (match-string 2))
                         (when-closed (org-parse-time-string time-string)))
                    (if (>= (time-to-number-of-days
                             (time-subtract (current-time)
                                            (apply #'encode-time when-closed)))
                            org-my-archive-expiry-days)
                        (org-archive-subtree)))))))))
      
      (defalias 'archive-done-tasks 'asdflökg)
    #+end_example
*** Smarter headlines

    from: http://lists.gnu.org/archive/html/emacs-orgmode/2007-10/msg00551.html
    Hi,
    
    Here's a small piece of elisp code that might be useful to some of
    you.  Pressing '*' now inserts '*' as before, but if there are only
    spaces between the beginning of the current line and the point,
    then all of them are converted to stars.  Useful for inserting new
    headlines.
    
    Longer explanaition: assume you have the following structure:
    
    * first level headline
    _* second level headline
    __* third level headline

    (_ denotes an invisible star) Since stars are invisible, I often
    find myself trying to create a new subheadline by just inserting a
    single star

    * first level headline
    _* second level headline
    __* third level headline
       *

    which of course doesn't normally work, hence this elisp code.

    #+begin_src emacs-lisp
      (defun local-org-insert-stars ()
        (interactive)
        (when (looking-back "^ *" (point-at-bol))
          (replace-string " " "*" nil (point-at-bol) (point)))
        (insert "*"))
      
      (define-key org-mode-map "*" 'local-org-insert-stars)
    #+end_src
    Haven't thoroughly tested it, but it seems to work ok.

    Piotr

*** Filesets for OrgFiles                                          :filesets:
    
    A Nice fileset definition for my local org files and one for my shared org files.
    #+begin_src emacs-lisp
      ;; for some reason I don't understand this does not work, must have
      ;; something todo evaluation of variables.
      ;;(add-to-list 'filesets-data (quote ("OrgFiles" 
      ;;                                    (:tree local-org-files-dir 
      ;;                                           "^.+\\.org$")
      ;;                                    (:tree-max-level 2))))
      ;;(add-to-list 'filesets-data (quote ("OrgFiles" 
      ;;                                    (:tree shared-org-files-dir 
      ;;                                           "^.+\\.org$")
      ;;                                    (:tree-max-level 2))))
      
    #+end_src

*** Logging and clocking
    
    I want to have the change to enter a message for every change a
    make to items that are scheduled and for what I make with my
    time. It's easy to ignore if not needed I just pres C-c C-c, and no
    message will be saved.

    #+begin_src emacs-lisp
      (setq org-clock-into-drawer t)
      (setq org-log-into-drawer t)
      (setq org-log-redeadline (quote note))
      ;; Show lot sof clocking history so it's easy to pick items off the list
      (setq org-clock-history-length 72)
      ;; Resume clocking task on clock-in if the clock is open
      (setq org-clock-in-resume t)
      ;; This removes clocked tasks with 0:00 duration
      (setq org-clock-out-remove-zero-time-clocks t)
      ;; Clock out when moving task to a done state
      (setq org-clock-out-when-done t)
      ;; Save the running clock and all clock history when exiting Emacs, load it on startup
      (setq org-clock-persist t)
      ;; Do not prompt to resume an active clock
      (setq org-clock-persist-query-resume nil)
      ;; Enable auto clock resolution for finding open clocks
      (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
      ;; Include current clocking task in clock reports
      (setq org-clock-report-include-clocking-task t) 
      ;; resurrect clock and clocking history
      ;; this need to be placed after Local and Shared init of org-files so
      ;; we have all files where we should look for clocked in tasks.
      (org-clock-persistence-insinuate)
    #+end_src
    
    #+begin_src emacs-lisp

    #+end_src
*** Agenda                                                           :habits:
    #+begin_example emacs-lisp
      ;; does not work at the moment
      (setq org-agenda-custom-commands
            '(("d" "Upcoming deadlines" agenda "" 
               ((org-agenda-time-grid nil)
                (org-deadline-warning-days 365)        ;; [1]
                (org-agenda-entry-types '(:deadline))  ;; [2]
                ))
              ;; other commands go here
              ("W" "Weekly" 
               ((agenda "" 
                        ((org-agenda-ndays 7)
                         (org-agenda-log-mode t)
                         )
                        )
                ))
              ))
    #+end_example
    #+begin_src emacs-lisp
      (setq org-habit-graph-column 50)
      (setq org-agenda-tags-column 75)
      (setq org-habit-show-habits-only-for-today nil)
      (setq org-habit-preceding-days 15)
      (setq org-habit-following-days 10)      
    #+end_src

    From Julien Danjou we borrow a function to be able to get our own
    Holidays and Vaction days marked in the right face.  for this to
    kick in you need to set the category on items to "Holidays" or
    "Vacation".

    #+begin_src emacs-lisp
    (setq org-agenda-day-face-function
       (defun jd:org-agenda-day-face-holidays-function (date)
         "Compute DATE face for holidays."
         (unless (org-agenda-todayp date)
           (dolist (file (org-agenda-files nil 'ifmode))
             (let ((face
                    (dolist (entry (org-agenda-get-day-entries file date))
                      (let ((category (with-temp-buffer
                                        (insert entry)
                                        (org-get-category (point-min)))))
                        (when (or (string= "Holidays" category)
                                  (string= "Vacation" category))
                          (return 'org-agenda-date-weekend))))))
               (when face (return face)))))))
    #+end_src

***** Diary integration

      functions to use in the agenda view, include calles to these
      functions in one of your agenda files like this %%(diary-sun*) and
      it will be called.
      #+begin_src emacs-lisp
        ;; functions to use in the dairy to get seperated sunrise and sunset times.
        ;; if we use %%(dairy-sunrise-sunset) we get it on one line, this gives us
        ;; two lines or only one if we want to.
        (defun diary-sunrise ()
          (let ((dss (diary-sunrise-sunset)))
            (with-temp-buffer
              (insert dss)
              (goto-char (point-min))
              (while (re-search-forward " ([^)]*)" nil t)
                (replace-match "" nil nil))
              (goto-char (point-min))
              (search-forward ",")
              (buffer-substring (point-min) (match-beginning 0)))))
        
        (defun diary-sunset ()
          (let ((dss (diary-sunrise-sunset))
                start end)
            (with-temp-buffer
              (insert dss)
              (goto-char (point-min))
              (while (re-search-forward " ([^)]*)" nil t)
                (replace-match "" nil nil))
              (goto-char (point-min))
              (search-forward ", ")
              (setq start (match-end 0))
              (search-forward " at")
              (setq end (match-beginning 0))
              (goto-char start)
              (capitalize-word 1)
              (buffer-substring start end))))
      #+end_src
      
      We also need to set where on earth we are because without that
      information the dairy-sun* functions can not do it's job and
      will ask every time we start where on earht we are.
      #+begin_src emacs-lisp
        (setq calendar-latitude 63.1766)
        (setq calendar-longitude 14.636068)
        (setq calendar-location-name "Östersund, Sweden")
      #+end_src
*** TODO Exports
*** Babel
***** SQL
      Sometimes I use sql in org-babel, for that I have modified version
      of 'ob-sql.el' my modifications are so I can use it together with
      oracle. It still need some more fixing before a send a patch for it
      to the maintainers.

      #+begin_src emacs-lisp
        ;; we use a safe way of loading it, it should alawys exist but if it
        ;; does not, we don't want an error.
        (when (require 'ob-sql nil 'noerror) 
          (message "loaded ob-sql, you can now use sql in org-babel snippets")
          )
      #+end_src

*** Org-sync
    #+begin_example emacs-lisp
      (load-file "org-modules/org-element.el")
      (load-file "org-sync2/os.el") ;; org-sync
      (load-file "org-sync2/os-github.el") ;; github
      ;;(load-file "org-sync2/and os-bb.el") ;; bitbucket  
    #+end_example

*** Post

    Read [[Init]]. here is the last call and it gives the local a chance to
    overide everything from the shared org-directory.

    #+begin_src emacs-lisp
      (org-babel-load-file (concat shared-org-files-dir "post.org"))
      (org-babel-load-file (concat local-org-files-dir "post.org"))
    #+end_src

* Google Integration
  most of these things comes from http://julien.danjou.info/
*** Google maps                                                         :org:
    #+begin_src emacs-lisp
      (add-to-list 'load-path (concat local-emacs-org-dir
                                      "google-maps"))
      (when (require 'google-maps nil 'noerror)
        (when (require 'org-location-google-maps nil 'noerror)))
    #+end_src
    You can then use M-x google-maps and type a location.
    
    Various key bindings are available. Here's a few:
    
    + or - to zoom in or out;
    left, right, up, down to move;
    z to set a zoom level via prefix;
    q to quit;
    m to add or remove markers;
    c to center the map on a place;
    C to remove centering;
    t to change the maptype;
    w to copy the URL of the map to the kill-ring;
    h to show your home.
    You can integrate directly Google Maps into Org-mode:

    Then you can use C-c M-L to enter a location assisted by Google
    geocoding service. Pressing C-c M-l will show you a map.

    If you want to use advanced feature, you should take a look at
    google-maps-static-show and google-maps-geocode-request functions.

*** Google Weather                                                      :org:

    #+begin_src emacs-lisp
      (add-to-list 'load-path (concat local-emacs-org-dir "google-weather"))
      (when (require 'google-weather nil 'noerror))
    #+end_src

    The function are documented, therefore you should not have any
    difficulty to use them.

    If you want to use org-google-weather to add weather forecasts in
    your agenda, just add the following in your .emacs.

    #+begin_src emacs-lisp
      (when (require 'org-google-weather nil 'noerror)
        ;; We have the icons in a subdirectory
        (setq org-google-weather-icon-directory (concat local-emacs-org-dir 
                                                        "google-weather-icons"))
        ;; here we map icons names to different weather conditions
        ;; on windows we use png's else svg's
        (if (eq system-type 'windows-nt)
            (setq org-google-weather-icon-alist
                  '((chance_of_rain . "weather-showers-scattered.png")
                    (chance_of_snow . "weather-snow.png")
                    (chance_of_storm . "weather-storm.png")
                    (cn_cloudy . "weather-overcast.png")
                    (cn_heavyrun . "weather-showers.png")
                    (cn_sunny . "weather-clear.png")
                    (cloudy . "weather-overcast.png")
                    (dust . "weather-fog.png")
                    (flurries . "weather-storm.png")
                    (fog . "weather-fog.png")
                    (haze . "weather-fog.png")
                    (icy . "weather-snow.png")
                    (jp_sunny . "weather-clear.png")
                    (jp_cloudy . "weather-overcast.png")
                    (mist . "weather-storm.png")
                    (mostly_cloudy . "weather-overcast.png")
                    (mostly_sunny . "weather-clear.png")
                    (partly_cloudy . "weather-few-clouds.png")
                    (rain . "weather-showers.png")
                    (rain_snow . "weather-snow.png")
                    (sleet . "weather-snow.png")
                    (smoke . "weather-fog.png")
                    (snow . "weather-snow.png")
                    (storm . "weather-storm.png")
                    (thunderstorm . "weather-storm.png")
                    (sunny . "weather-clear.png")))
          (setq org-google-weather-icon-alist
                  '((chance_of_rain . "weather-showers-scattered.svg")
                    (chance_of_snow . "weather-snow.svg")
                    (chance_of_storm . "weather-storm.svg")
                    (cn_cloudy . "weather-overcast.svg")
                    (cn_heavyrun . "weather-showers.svg")
                    (cn_sunny . "weather-clear.svg")
                    (cloudy . "weather-overcast.svg")
                    (dust . "weather-fog.svg")
                    (flurries . "weather-storm.svg")
                    (fog . "weather-fog.svg")
                    (haze . "weather-fog.svg")
                    (icy . "weather-snow.svg")
                    (jp_sunny . "weather-clear.svg")
                    (jp_cloudy . "weather-overcast.svg")
                    (mist . "weather-storm.svg")
                    (mostly_cloudy . "weather-overcast.svg")
                    (mostly_sunny . "weather-clear.svg")
                    (partly_cloudy . "weather-few-clouds.svg")
                    (rain . "weather-showers.svg")
                    (rain_snow . "weather-snow.svg")
                    (sleet . "weather-snow.svg")
                    (smoke . "weather-fog.svg")
                    (snow . "weather-snow.svg")
                    (storm . "weather-storm.svg")
                    (thunderstorm . "weather-storm.svg")
                    (sunny . "weather-clear.svg")))))
    #+end_src
    Then, add the following in one of your Org file.

    #+begin_example
      * Weather
        %%(org-google-weather "New York")
    #+end_example

    You can set the language as second argument. You should know that
    the unit system used is language dependent. By default, American
    English is used, therefore with Fahrenheit degrees, but if you want
    to have English with Celsius degrees, you can use "en-gb".
***** TODO find out why emacs for windows does not support svg, and fix it.
      The svgs looks so much nicer.
***** TODO modify the svg's to be smaller.
***** TODO We want weather first on every day
      tried setting with high priority that may bump it up the
      agenda. will have to check that at home.
***** DONE copy icons for the different weather symbols.
      we need the symbols from [[/usr/share/icons/gnome/16x16/status]] to be
      added to the repo so we also have them on windows. 
      these are the one needed.
      - "weather-clear.png")
      - "weather-few-clouds.png")
      - "weather-fog.png")
      - "weather-overcast.png")
      - "weather-showers-scattered.png")
      - "weather-showers.png")
      - "weather-snow.png")
      - "weather-storm.png")
***** DONE make sure it works on windows with svg or else change to png's
      :LOGBOOK:
      CLOCK: [2012-08-21 ti 11:11]--[2012-08-21 ti 11:13] =>  0:02
      - I does not work with svg, need png's on windows. emacs on
        windows does not support svg.
      CLOCK: [2012-08-20 må 10:35]--[2012-08-20 må 11:46] =>  1:11
      :END:
*** Google Contacts                                                  :oauth2:
    http://julien.danjou.info/projects/emacs-packages#google-contacts

    The easiest way to use it is to load it from your .emacs:
    #+begin_src emacs-lisp
      (add-to-list 'load-path (concat local-emacs-org-dir "google-contacts"))
      (when (require 'google-contacts nil 'noerror))
    #+end_src
    You can then use M-x google-contacts and type a query string.
    
    Various key bindings are available. Here's a few:
    
    n or p to go the next or previous record;
    g to refresh the result, bypassing the cache;
    m to send an e-mail to a contact;
    s to make a new search;
    q to quit.
    You can integrate directly Google Contacts into Gnus:

    #+begin_src emacs-lisp
      (when (require 'google-contacts-gnus nil 'noerror))
    #+end_src
    Then you can use ; to go to a contact information while reading an
    e-mail.
    
    You can integrate directly Google Contacts into message-mode;

    #+begin_src emacs-lisp
      (when (require 'google-contacts-message nil 'noerror))
    #+end_src
    Then you can use TAB to go to complete e-mail addresses in the
    header fields.
* Remember
  
  I don't use remember as much at the moment but some day or some
  other function once I have found out which I shall use. Most of this
  has been copied from someones GTD.org setup.

  #+begin_src emacs-lisp
    (autoload 'remember "remember" nil t)
    (autoload 'remember-region "remember" nil t)
    (setq remember-annotation-functions '(org-remember-annotation))
    (setq remember-handler-functions '(org-remember-handler))
    (add-hook 'remember-mode-hook 'org-remember-apply-template)
    (setq org-remember-templates
         '(
          ("Todo" ?t "** TODO %^{Brief Description} %^g\n%?\nAdded: %U" "~/Dokument/GTD/gtd.org" "Tasks")
          ("Private" ?p "\n* %^{topic} %T \n%i%?\n" "~/Dokument/GTD/gtd.org" "Private")
          ("WordofDay" ?w "\n* %^{topic} \n%i%?\n" "~/Dokument/GTD/wotd.org")
          ))
  #+end_src

* TODO Other Setup

  #+begin_src emacs-lisp
    ; dont use tabs for indenting
    (setq-default indent-tabs-mode t)
    
    (define-key global-map "\C-cl" 'org-store-link)
    (define-key global-map "\C-ca" 'org-agenda)
    
    (define-key global-map "\C-cr" 'org-remember)
        
    (define-key global-map [f8] 'remember)
    (define-key global-map [f9] 'remember-region)
        
    (global-set-key "\C-x\C-r" 'prefix-region)
    (global-set-key "\C-x\C-l" 'goto-line)
    ;;(global-set-key "\C-x\C-y" 'copy-region-as-kill)
  #+end_src

* Load Local settings

  Last but not least we need to load the part of the .emacs that is
  local to this machine. That is also a org-babel emacs file.

  #+begin_src emacs-lisp
    (add-to-list 'load-path (concat local-emacs-org-dir "local"))
    (org-babel-load-file (concat local-emacs-org-dir "local/emacs.org"))
  #+end_src

* Filesets                                                          :filesets:

The commands that can operate on file sets are specified in the global
custom variable "filesets-commands". You can add your own commands to
that list. The default value for this variable is: 

("Isearch" multi-isearch-files
  (filesets-cmd-isearch-getargs))
 ("Isearch (regexp)" multi-isearch-files-regexp
  (filesets-cmd-isearch-getargs))
 ("Query Replace" perform-replace
  (filesets-cmd-query-replace-getargs))
 ("Query Replace (regexp)" perform-replace
  (filesets-cmd-query-replace-regexp-getargs))
 ("Grep <<selection>>" "grep"
  ("-n " filesets-get-quoted-selection " " "<<file-name>>"))
 ("Run Shell Command" filesets-cmd-shell-command
  (filesets-cmd-shell-command-getargs)))

The values consist of an association list of names, functions, and an
argument list (or a function that returns one) to be run on a
filesets' files. So, if you wanted to add a command that does an
"occur" command on the file set, you could use the "Isearch" entry as
an example to create your own new entry (that you would add to the
"filesets-commands" global variable) that would look something like: 

 ("Occur (regexp)" multi-occur-files-regexp
  (filesets-cmd-occur-getargs))

You would need to write the "multi-occur-files-regexp" and
"filesets-cmd-occur-getargs" functions (you could use the existing
"multi-isearch-files-regexp" and "filesets-cmd-isearch-getargs"
functions as a basis since they would be similar). The same would
apply for any additional Emacs command that you wanted to add to work
on file sets. 

  #+begin_src emacs-lisp
    ;; now when both shared and local config has been parsed we should be
    ;; able to init the filesets menu.
    (filesets-init)
  #+end_src
  
* TODO ERC

  #+begin_src emacs-lisp
    (require 'erc-join)    
    (require 'erc-match)
    (setq erc-keywords '("darion" "kurohin"))
    
    ;; Exclude messages sent by the server when you join a channel, such as the nicklist and topic:
    (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                    "324" "329" "332" "333" "353" "477"))
    
    (defun jiha-erc-after-connect-hook (SERVER NICK))
    
    (add-hook 'erc-after-connect 'jiha-erc-after-connect-hook)
    
    (erc-autojoin-mode 1)
    (setq erc-autojoin-channels-alist
          ;; localhost should have a ssh tunnel to my server
          '(("localhost" "#emacs" "#org-mode" "#erc")
            ("oftc.net" "#BitlBee")))
    
    (defun irc-maybe ()
      "Connect to IRC."
      (interactive)
      (when (y-or-n-p "IRC? ")
        ;; should be a ssh tunnel to freenode
        (erc :server "localhost" :port 6667
             :nick "kurohin" :full-name "Jim Hansson")
        ;;(erc :server "irc.oftc.net" :port 6667
        ;;     :nick "kurohin" :full-name "Jim Hansson")
        ;; should be a ssh tunnel to testing.bitlbee.org
        (erc :server "localhost" :port 7000
             :nick "kurohin" :full-name "Jim Hansson")))
    
    ;; logging:
    (setq erc-log-insert-log-on-open nil)
    (setq erc-log-channels t)
    (setq erc-log-channels-directory "~/.irclogs/")
    (setq erc-save-buffer-on-part t)
    (setq erc-hide-timestamps nil)
    
    (defadvice save-buffers-kill-emacs (before save-logs (arg) activate)
      (save-some-buffers t (lambda () (when (and (eq major-mode 'erc-mode)
                                                 (not (null buffer-file-name)))))))
    
    (add-hook 'erc-insert-post-hook 'erc-save-buffer-in-logs)
    (add-hook 'erc-mode-hook '(lambda () (when (not (featurep 'xemacs))
                                           (set (make-variable-buffer-local
                                                 'coding-system-for-write)
                                                'emacs-mule))))
    ;; end logging
    
    ;; Truncate buffers so they don't hog core.
    (setq erc-max-buffer-size 20000)
    (defvar erc-insert-post-hook)
    (add-hook 'erc-insert-post-hook 'erc-truncate-buffer)
    (setq erc-truncate-buffer-on-save t)
    
    (erc-timestamp-mode t)
    (setq erc-timestamp-format "[%R-%m/%d]")
    
    (global-set-key (kbd "C-c I") 'reset-erc-track-mode)
    (setq erc-auto-query 'buffer)
    
  #+end_src

* BBDB

#+begin_src emacs-lisp
  (add-to-list 'load-path (concat local-emacs-org-dir "bbdb2/lisp"))
  ;;(require 'bbdb)
  ;;(bbdb-initialize 'gnus 'message)
  ;;(add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
#+end_src
  
  other stuff i might need
  (provide 'bbdb-autoloads)
  (if
  (and load-file-name
  (file-name-directory load-file-name))
  (add-to-list 'load-path (file-name-directory load-file-name)))

* List of others configurations that you can look at and steal ideas from

  - http://git.naquadah.org/git/~jd/emacs.d.git :: http://julien.danjou.info/

#  LocalWords:  Uniquify Iswitch emacs src Whitespace
