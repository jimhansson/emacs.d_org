# -*- mode: org; coding: utf-8-unix -*-
#+TITLE: My emacs configuration
#+AUTHOR: Jim Hansson
#+EMAIL: jim.hansson@gmail.com 
#+DATE: <2012-06-28 to>
#+LANGUAGE: English

This is my main .emacs file. It is responsible for calling out to the local file at
different points. This is placed in a git repository that I share between work and home

* File setup
#+STARTUP: hidestars hideblocks
#+COLUMNS: %50ITEM %4TODO %20TAGS
#+LINK: norang http://doc.norang.ca/org-mode.html#
#+LINK: wiki http://emacswiki.org/emacs/
	
* Bugs
	:LOGBOOK:
	CLOCK: [2014-06-09 må 14:55]--[2014-06-09 må 16:40] =>  1:45
	- changed omnisharp to be from elpa instead of using my own version.
	:END:
*** TODO CSharp mode does something funny with { in csharp-mode
		it does not let me use cc-mode indentation to control what should be indented and how.
*** TODO check out script in org-outlook, for new ideas.
*** TODO I don't want submodules to show up in git status
		:LOGBOOK:
		CLOCK: [2013-03-11 må 22:13]--[2013-03-11 må 22:52] =>  0:39
		:END:
*** TODO I want to use tabs for indentation instead of spaces
		this might not be a good idea with lisp but I should try it out.

*** TODO add some classes for directories that are not by default writeable
		http://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html#Directory-Variables
*** TODO replace setq and other things with custom-set-variables calls
		:LOGBOOK:
		CLOCK: [2013-07-03 on 00:00]--[2013-07-03 on 00:39] =>  0:39
		:END:
		
		might allow for using custom for changing varibles?? also does require on things.

		seems that the function that i should use i customize-set-variable instead.

*** TODO add ibuffer "layouts" that are different between work, code, home, otherstuff....

		- I need one for work related stuff that are not code, things like mail, org-files...
		- I need one for coding.
		- I need one for private stuff

*** TODO Things that does not work after uppgrade

		these two things gives wierd errors after uppgrade, we need find out if they are still
		needed or if they can be removed.

		#+BEGIN_EXAMPLE
      ;; resurrect clock and clocking history
      ;; this need to be placed after Local and Shared init of org-files so
      ;; we have all files where we should look for clocked in tasks.
      ;;(org-clock-persistence-insinuate)

      ;; because of org-mode modular structure some variables and other
      ;; things are not known before you have used them once, this solves
      ;; that problem at least partially.
      ;;(org-require-autoloaded-modules)
      
		#+END_EXAMPLE
		
*** TODO advice tabify/untabify to use the whole buffer if no region is marked. :noexport:
		:LOGBOOK:
		CLOCK: [2014-02-05 on 12:15]--[2014-02-05 on 15:17] =>  3:02
		CLOCK: [2014-02-04 ti 12:15]--[2014-02-04 ti 15:50] =>  3:35
		:END:

		does not work at the moment as I would like it to need to fix it somehow.
		#+BEGIN_SRC elisp
      (defadvice tabify (around mark-whole-buffer-if-no-region activate)
        "When using tabify without marking a region, the normal thing in emacs is to do tabify
      on everthing below point, this feel unatural, this changes that to instead do it on the
      whole buffer."
        (save-excursion
          (if (not (region-active-p)) 
              (progn
                (mark-whole-buffer)
                (ad-do-it)))))
        
		#+END_SRC

		#+RESULTS:
		: tabify

		#+BEGIN_SRC elisp
		(ad-disable-advice 'tabify 'around 'mark-whole-buffer-if-no-region)
		#+END_SRC

  #+RESULTS:

* Introduction
	Basic things that could have been done throu custom-set-variable but
	then I would have harder time to replicate that between machines.
	
	when doing a new installation on either windows or linux check the
	items with the tags below for specific things you have to do outside
	emacs to get things working.
	
	- instw :: for windows specific things.
	- instl :: for linux specific things.

*** Requirements
		:PROPERTIES:
		:ID:       17307662-9183-417f-a32e-7f2d7030f477
		:END:

		- Emacs 24
		- a basic .emacs file that calls this after it inits org-babel 
		- a lot of extra packages. most configuration will check for it

		First we need to setup the package system in emacs

		#+BEGIN_SRC emacs-lisp
      (if (require 'package)
          (let ((archives  '(("ELPA" . "http://tromey.com/elpa/") ;;(ref:let)
                             ("gnu" . "http://elpa.gnu.org/packages/")
                             ("marmalade" . "http://marmalade-repo.org/packages/")
                             ("melpa" . "http://melpa.milkbox.net/packages/")
                             ("SC" . "http://joseito.republika.pl/sunrise-commander/"))))
            (progn
              (dolist (archive archives)                          ;;(ref:add)
                (progn 
                  (add-to-list 'package-archives archive)))
             
              (package-initialize)                                 ;;(ref:load)
              ))
             ;;(unless (and (file-exists-p "~/.emacs.d/elpa/archives/marmalade")
             ;;      (file-exists-p "~/.emacs.d/elpa/archives/gnu") ;;(ref:refresh)
             ;;      (file-exists-p "~/.emacs.d/elpa/archives/melpa"))
             ;;      (package-refresh-contents)) )) 
             ;; If something goes wrong when requiring package
        (error "%s" "Error in config: initalizing packages"))
		#+END_SRC

		In [[let][LET expression]] we set up a local variable for all the package repository we would
		like to use, in this way that variable is not usable outside the part of the code that
		should be using it. [[add][DOLIST...ADD-TO-LIST expression]] we add all repositories to a the
		list used by the package-system, and finally in the [[load][PACKAGE-INITIALIZE]] we setup the
		packages for actual usage.

		the commented code with [[refresh][UNLESS...PACKAGE-REFRESH-CONTENT]] is something that could be
		used to do automatic updates from package repo:s, i should turn into something that
		loops over the archives variable.

		Then use M-x list-packages to find and install these packages.

*** What you need to have in your normal .emacs

		#+BEGIN_EXAMPLE
      ;; this is what is needed in the real .emacs file.
      ;; remember to change the paths at the bottom of this file
      
      (require 'cl)
      
      ;; set-up org babel
      (setq org-babel-load-languages '((emacs-lisp . t)))
      (setq org-confirm-babel-evaluate nil)
      (require 'org-install)
      (require 'org)
      
      ;; all these paths need '/' at the end
      (setq my-org-directories
            '("c:/Users/jiha/Documents/github/emacs.d_org/"
              "c:/Users/jiha/Documents/github/shared_org/"
              "c:/Users/jiha/Documents/org/"))
      ;; you need to change this
      (setq local-emacs-org-dir "c:/Users/jiha/Documents/github/emacs.d_org/")
      
      ;; avoids problem if you use some special characters in the emacs.org files
      (add-to-list 'file-coding-system-alist 
                   '("\\.el\\'" . utf-8-emacs))
      (add-to-list 'file-coding-system-alist
                   '("\\.org\\'" . utf-8-emacs))
      
      ;; load neatly organized org file!
      (add-to-list 'load-path local-emacs-org-dir)
      (org-babel-load-file (concat local-emacs-org-dir "emacs.org"))
		#+END_EXAMPLE

*** Things you should install from package-system														 :instw:instl:
		- oauth2 :: for google integration for some reason I need to add oauth directory to
		load-path, should not elpa take care of that. 
		- bookmark+ :: can do so much more than the normal bookmark package. 
		- magit :: good mode to handle git repos from within emacs, the normal VC functions in
		emacs are not so good at that.
		- org-magit :: Allows for links from org into magit buffers.
		- guess-style :: for coding
		- guess-offset :: for coding
		- csharp-mode :: for coding
		- multiple-cursors :: easy way of doing changes over more than one line instead of
         using a macro
		- expand-region :: really useful function that allows you to expand the marked region
                       by semantic bounderies of the major mode 

		Good things to have on Windows
		- org-outlook :: integration with outlook
		- powershell :: for coding
		- tfs :: for Team Foundation Server.
						 
		Not so important, but nice to have.
		- pretty-symbols


*** Other important stuff
***** Only load things that exists.

			that can be done this way, by using this instead of the normal require function. We
			will get a message that something could not be loaded but still work.

			#+BEGIN_SRC emacs-lisp
        (defmacro jiha-safe-require (what do)
          "Will try to require what and if that does succeed eval body, if it could not require what without an error print a message and keep on as nothing happend"
          `(if (require ,what nil 'noerror)
               ,do
             (message (format "Could not load %s" ,what))))
        
			#+END_SRC

   #+RESULTS:
	 : jiha-safe-require

			use it like this
			#+BEGIN_EXAMPLE
        (jiha-safe-require 'org-mode
         (things I only want to do if org-mode is working))
			#+END_EXAMPLE

* Global Things
*** Setup
		
		Some user information
		#+BEGIN_SRC emacs-lisp
			(setq user-full-name "Jim Hansson")
			(setq user-mail-address "jim.hansson@powel.se")		
		#+END_SRC

		Here we setup some basic things, I dont like the toolbar so that we turn off, I use
		OrgMode to almost everything(even my .emacs) so that will be my default mode. Almost
		all computers I use are laptops and who in there right mind uses 12h clocks. 

		#+BEGIN_SRC emacs-lisp
      (setq default-major-mode 'org-mode)
      (add-hook 'text-mode-hook 'turn-on-auto-fill)
      ;; show matching paren
      (show-paren-mode t)
      (delete-selection-mode 1) 
      (iswitchb-mode 1)
      (setq filesets-data nil)
      (global-font-lock-mode t)
      ;; binds ctrl + § to dabbrev as good enough completion 
      (global-set-key (kbd "C-\§") 'dabbrev-expand)
      (setq-default indent-tabs-mode t)
      (setq column-number-mode t)
      (setq global-auto-revert-mode t)
      (setq inhibit-startup-screen t)
      (setq inhibit-splash-screen t)
      (setq initial-buffer-choice t)
      (setq-default line-spacing 3)
      ;; This stops calls to sync when saving files, this might save battery on laptops, I only
      ;; have SSD so that does not affect me so much. Setting might make it easier to loss data
      ;; also.
      ;;(write-region-inhibit-fsync t)

		#+END_SRC

		#+BEGIN_SRC emacs-lisp
      (defadvice toggle-frame-fullscreen (before toggle-menu activate)
        "also hide the menu when going fullscreen"
        (menu-bar-mode)
        (scroll-bar-mode))
		#+END_SRC

  #+RESULTS:
	: toggle-frame-fullscreen

*** Disable warnings for first time users
		
		For some reason some questions in emacs are yes/no and some are y/n this trips me
		sometimes so we turn that off, and the same goes for killing emacs. We also removes
		some questions that are asked to make sure that the users really wants what is going
		to happen, I know how to use undo and I usually have some version control system
		running so I can go back.

		#+BEGIN_SRC emacs-lisp
      ;; Changes all yes/no questions to y/n type
      (fset 'yes-or-no-p 'y-or-n-p)
      (set-variable 'confirm-kill-emacs 'yes-or-no-p)
      ;; more of these as I find them
      (put 'narrow-to-region 'disabled nil)
      (setq safe-local-variable-values 
            (quote ((auto-fill-mode . t) (indent-tab-mode))))
		#+END_SRC

*** Uniquify																														:uniquify:buffers:

		Better naming of buffers so we can easly tell the differens between
		buffers. Have some problem together with Iswitch

		#+BEGIN_SRC emacs-lisp
			(require 'uniquify)
			(setq uniquify-buffer-name-style (quote post-forward))
		#+END_SRC

*** Tool-Bar

		#+BEGIN_SRC emacs-lisp
      (tool-bar-mode -1)
		#+END_SRC

*** Menu-Bar

		Good as it is.

*** Mode-line																																		:modeline:
		
		this for the normal mode-line, but if we have powerline installed that will may be
		used instead, configuration for that is below

		#+BEGIN_SRC emacs-lisp
      ;; Things that modifies the modeline
      (setq display-battery-mode t)
      (setq display-time-24hr-format t)
      ;; I work width some really big files and then it is good to have this
      ;; so i know how far down I am.
      (setq size-indication-mode t)
		#+END_SRC

***** remove which function																			:headerline:whichfunction:
			we remove which-function from the modeline because we are going to place that in
			headerline instead

			#+BEGIN_SRC emacs-lisp
      	(setq mode-line-misc-info
                  	;; We remove Which Function Mode from the mode line, because it's mostly
                  	;; invisible here anyway.
                  	(assq-delete-all 'which-func-mode mode-line-misc-info))		
			#+END_SRC
***** PowerLine

			#+BEGIN_SRC emacs-lisp
        (jiha-safe-require 
         'powerline
         ())

			#+END_SRC

*** Header line																									:headerline:whichfunction:

		#+BEGIN_SRC emacs-lisp
      (which-function-mode 1)
      (setq-default header-line-format
                    '((which-func-mode ("" which-func-format " "))))
		#+END_SRC

*** Scrolling

		#+BEGIN_SRC emacs-lisp
      ;; This removes most of the jumping, but it might still jump.
      
      ;; Allways want scroll-bars on right side.
      (setq scroll-bar-mod 'right)
      ;;(setq scroll-bar-width ??)
      
      ;; we don't want scroll margin when scrolling horizontal, because when we are editing
      ;; thing far out to the right, it should not jump until it needs to.
      (setq scroll-margin 7)
      
      ;; Smoother scrolling, less jumping.
      (setq scroll-step 1)
      
      ;; This I don't know what it does.
      (setq auto-window-vscroll nil)
      
      ;; Mouse scroll
      ;; scroll one line at a time (less "jumpy" than defaults)
      ;; one line at a time
      (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
      ;; don't accelerate scrolling
      (setq mouse-wheel-progressive-speed t)
      ;; scroll window under mouse
      (setq mouse-wheel-follow-mouse 't)
		#+END_SRC
*** Midnight																																		:midnight:

		Midnight mode is a package by SamSteingold? that comes with Emacs for running
		configured actions at every “midnight”. By default, the ‘midnight-hook’ is configured
		to just run the CleanBufferList command.

		Run ‘M-x customize-group RET midnight RET’ to configure and easily turn on Midnight
		mode.

		Many people choose to configure Midnight mode entirely in their InitFile. That is how
		it will be explained below, since some EmacsLisp bits are needed even with
		CustomMode?.

		To use Midnight mode, it needs to be included with ‘require’.

		#+BEGIN_SRC emacs-lisp
      (require 'midnight)
		#+END_SRC

		It also needs to be enabled with the function ‘midnight-delay-set’
		which also defines “midnight”.

		#+BEGIN_SRC emacs-lisp
      ;;(midnight-delay-set 'midnight-delay "4:30am")
      ;;Some people use the number of seconds after midnight:
      (midnight-delay-set 'midnight-delay 16200) ;; (eq (* 4.5 60 60) "4:30am")
      
		#+END_SRC

		To add other actions to be run at midnight, add to the hook
		‘midnight-hook’. 
		
		#+BEGIN_EXAMPLE emacs-lisp
      (add-hook 'midnight-hook(lambda
                               (with-current-buffer "*cvs*"
           (call-interactively 'cvs-update))))
      (add-hook 'midnight-hook 'calendar)
      
      ;;You can disable midnight mode with ‘cancel-timer’.
      
      (cancel-timer 'midnight-timer)
		#+END_EXAMPLE

		If you want to have “midnight” occur multiple times a day, you can
		change the ‘midnight-period’ from 24 hours to something else. 

		#+BEGIN_EXAMPLE emacs-lisp
			(setq midnight-period 7200) ;; (eq (* 2 60 60) "2 hours")		 
		#+END_EXAMPLE
		
		As of 2009-10-02, DeskTop mode does not preserve the value of
		‘buffer-display-time’ for buffers, so the buffer’s “age” is
		effectively restarted. This means that buffers restored by a
		Desktop sessions are considered “new” by CleanBufferList, even
		though they may be considered “old”. 

*** Expand-region
		
		#+BEGIN_SRC emacs-lisp
      (jiha-safe-require 'expand-region
        (progn
          (global-set-key (kbd "C-+") 'er/expand-region)
          (global-set-key (kbd "C--") 'er/contract-region)))
      
		#+END_SRC

  #+RESULTS:
	: er/contract-region

*** Multiple-cursors
		
		multiple-cursors.el [![Build Status](https://secure.travis-ci.org/magnars/multiple-cursors.el.png)](http://travis-ci.org/magnars/multiple-cursors.el)
		
		Multiple cursors for Emacs. This is some pretty crazy functionality, so yes,
		there are kinks. Don't be afraid tho, I've been using it since 2011 with
		great success and much merriment.
		
***** Basic usage
			
			Start out with:
			
			#+BEGIN_SRC emacs-lisp
        (jiha-safe-require 'multiple-cursors
         ())
        
			#+END_SRC
			
			Then you have to set up your keybindings - multiple-cursors doesn't presume to
			know how you'd like them laid out. Here are some examples:
			
			When you have an active region that spans multiple lines, the following will
			add a cursor to each line:
			
			(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
			
			When you want to add multiple cursors not based on continuous lines, but based on
			keywords in the buffer, use:
			
			(global-set-key (kbd "C->") 'mc/mark-next-like-this)
			(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
			(global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
			
			First mark the word, then add more cursors.
			
			To get out of multiple-cursors-mode, press `<return>` or `C-g`. The latter will
			first disable multiple regions before disabling multiple cursors. If you want to
			insert a newline in multiple-cursors-mode, use `C-j`.
			
***** Video
			
			You can [watch an intro to multiple-cursors at Emacs Rocks](http://emacsrocks.com/e13.html).
			
***** Command overview

******* Mark one more occurrence

       - `mc/mark-next-like-this` :: Adds a cursor and region at the next part of the buffer forwards that matches the current region.
       - `mc/mark-next-word-like-this` :: Like `mc/mark-next-like-this` but only for whole words.
       - `mc/mark-next-symbol-like-this` :: Like `mc/mark-next-like-this` but only for whole symbols.
       - `mc/mark-previous-like-this` :: Adds a cursor and region at the next part of the buffer backwards that matches the current region.
       - `mc/mark-previous-word-like-this` :: Like `mc/mark-previous-like-this` but only for whole words.
       - `mc/mark-previous-symbol-like-this` :: Like `mc/mark-previous-like-this` but only for whole symbols.
       - `mc/mark-more-like-this-extended` :: Use arrow keys to quickly mark/skip next/previous occurances.
       - `mc/add-cursor-on-click` :: Bind to a mouse event to add cursors by clicking. See tips-section.

******* Mark many occurrences

       - `mc/edit-lines` :: Adds one cursor to each line in the current region.
       - `mc/edit-beginnings-of-lines` :: Adds a cursor at the start of each line in the current region.
       - `mc/edit-ends-of-lines` :: Adds a cursor at the end of each line in the current region.
       - `mc/mark-all-like-this` :: Marks all parts of the buffer that matches the current region.
       - `mc/mark-all-words-like-this` :: Like `mc/mark-all-like-this` but only for whole words.
       - `mc/mark-all-symbols-like-this` :: Like `mc/mark-all-like-this` but only for whole symbols.
       - `mc/mark-all-in-region` :: Prompts for a string to match in the region, adding cursors to all of them.
       - `mc/mark-all-like-this-in-defun` :: Marks all parts of the current defun that matches the current region.
       - `mc/mark-all-words-like-this-in-defun` :: Like `mc/mark-all-like-this-in-defun` but only for whole words.
       - `mc/mark-all-symbols-like-this-in-defun` :: Like `mc/mark-all-like-this-in-defun` but only for whole symbols.
       - `mc/mark-all-like-this-dwim` :: Tries to be smart about marking everything you want. Can be pressed multiple times.

******* Special

       - `set-rectangular-region-anchor` :: Think of this one as `set-mark` except you're marking a rectangular region.
       - `mc/mark-sgml-tag-pair` :: Mark the current opening and closing tag.
       - `mc/insert-numbers` :: Insert increasing numbers for each cursor, top to bottom.
       - `mc/sort-regions` :: Sort the marked regions alphabetically.
       - `mc/reverse-regions` :: Reverse the order of the marked regions.
 
***** Tips and tricks

      - To get out of multiple-cursors-mode, press `<return>` or `C-g`. The latter will
        first disable multiple regions before disabling multiple cursors. If you want to
        insert a newline in multiple-cursors-mode, use `C-j`. 

      - Sometimes you end up with cursors outside of your view. You can scroll the screen
        to center on each cursor with `C-v` and `M-v`. 

      - Try pressing `mc/mark-next-like-this` with no region selected. It will just add a
        cursor on the next line. 

      - Try pressing `mc/mark-all-like-this-dwim` on a tagname in html-mode.

      - Notice that the number of cursors active can be seen in the modeline.

      - If you get out of multiple-cursors-mode and yank - it will yank only from the
        kill-ring of main cursor. To yank from the kill-rings of every cursor use
        yank-rectangle, normally found at C-x r y. 

      - You can use `mc/reverse-regions` with nothing selected and just one cursor. It
        will then flip the sexp at point and the one below it.

      - If you would like to keep the global bindings clean, and get custom keybindings
        when the region is active, you can try
        [region-bindings-mode](https://github.com/fgallina/region-bindings-mode). 

			BTW, I highly recommend adding `mc/mark-next-like-this` to a key binding that's
			right next to the key for `er/expand-region`.
	
******* Binding mouse events
				
				To override a mouse event, you will likely have to also unbind the
				`down-mouse` part of the event. Like this:
				
				(global-unset-key (kbd "M-<down-mouse-1>"))
				(global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click)
				
				Or you can do like me and find an unused, but less convenient, binding:
				
				(global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click)
				
***** Unknown commands
			
			Multiple-cursors uses two lists of commands to know what to do: the run-once list
			and the run-for-all list. It comes with a set of defaults, but it would be beyond silly
			to try and include all the known Emacs commands.
			
			So that's why multiple-cursors occasionally asks what to do about a command. It will
			then remember your choice by saving it in `~/.emacs.d/.mc-lists.el`. You can change
			the location with:
			
			(setq mc/list-file "/my/preferred/file")
			
			
***** Known limitations
			
			- isearch-forward and isearch-backward aren't supported with multiple cursors. You
        should feel free to add a simplified version that can work with it. 
			- Commands run with `M-x` won't be repeated for all cursors.
			- All key bindings that refer to lambdas are always run for all cursors. If you need
        to limit it, you will have to give it a name. 
			- Redo might screw with your cursors. Undo works very well.
				
				
***** Contribute
			
			Yes, please do. There's a suite of tests, so remember to add tests for your
			specific feature, or I might break it later.
			
			You'll find the repo at:
			
			https://github.com/magnars/multiple-cursors.el
			
			To fetch the test dependencies:
			
			$ cd /path/to/multiple-cursors
			$ git submodule update --init
			
			Run the tests with:
			
			$ ./util/ecukes/ecukes --graphical
			
***** Contributors

      - [Takafumi Arakaki](https://github.com/tkf) has contributed several small improvements
      - [Marco Baringer](https://github.com/segv) contributed looping to mc/cycle and adding cursors without region for mark-more.
      - [Ivan Andrus](https://github.com/gvol) added showing number of cursors in mode-line
      - [Fuco](https://github.com/Fuco1) added the first version of `mc/mark-all-like-this-dwim`
				
			Thanks!
			
***** License
			
			Copyright (C) 2012 Magnar Sveen
			
			Author: Magnar Sveen <magnars@gmail.com>
			Keywords: editing cursors
			
			This program is free software; you can redistribute it and/or modify
			it under the terms of the GNU General Public License as published by
			the Free Software Foundation, either version 3 of the License, or
			(at your option) any later version.
			
			This program is distributed in the hope that it will be useful,
			but WITHOUT ANY WARRANTY; without even the implied warranty of
			MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
			GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public License
			along with this program.  If not, see <http://www.gnu.org/licenses/>.

*** Server
		
		I run emacs with a shortcut containing, this starts a new emacs if nothing is running
		else it connects the the same one

		#+BEGIN_QUOTE
      C:\ProgramData\chocolatey\bin\emacsclientw.exe -n -a "C:\ProgramData\chocolatey\bin\runemacs.exe" -e "(make-frame-visible)"		
		#+END_QUOTE

		#+BEGIN_SRC emacs-lisp

      ;; start server if it's not running
      (require 'server)
      (unless (server-running-p)
        (server-start))

      ;; allows me to kill a buffer that has been brought up by client in a normal fashion.
      (defun jiha-mark-buffer-as-done ()
        "Marks this buffer as done and kills it. hides the window"
        (interactive)
        (server-edit)
        (make-frame-invisible nil t))

      ;; rebind things
      (global-set-key (kbd "C-x C-c") 'jiha-mark-buffer-as-done)
      (global-set-key (kbd "C-M-x C-M-c") 'save-buffers-kill-emacs)

		#+END_SRC

* Minor Modes

	We configure the basics of minor modes first, before the majors modes. in the major
	modes configuration we may adapt th minor modes for that specific major mode, but here
	we have the general configuration of the minor mode.
	
*** Auto-Fill
		
		#+BEGIN_SRC emacs-lisp
      (setq-default fill-column 90)
      ;; insert double space after colon
      ;;(setq-default colon-double-space t)
      
      ;; You can control how emacs breaks lines when filling by adding functions to this hook,
      ;; If the function returns non-nil it will not break the line. the function get point as
      ;; argument.
      ;; (add-hook fill-nobreak-predicate fill-single-word-nobreak-p ...)
		#+END_SRC

*** Auto-Saving
		
		#+BEGIN_SRC emacs-lisp
      ;; auto-save is a buffer-local minor mode, that means you can turn it on/off for the
      ;; specific file your are editing.
      
      ;; This means that after 500 chars we will autosave, the normal here is 300 chars
      (setq auto-save-interval 500)
      ;; after 180 seconds of idle time we will autosave, normal is 30 but I don't want it to run
      ;; just because I had to look something up in a mail.
      (setq auto-save-timeout 180)
      
      ;; there is also a hook you could use to do things before auto-saving is done.
      ;;(add-hook 'auto-save-hook ...)
		#+END_SRC

*** Fly-spell																																 :keybindings:

		My spelling is terrible so we use fly-spell as much as possible when it is
		available. It needs to be easy to activate and deactivate, we also need an easy way to
		spell-check only one word, the one at point and last it needs to be easy to change
		dictionaries.

		I highly suggest setting ‘flyspell-issue-message-flag’ to nil, as printing messages
		for every word (when checking the entire buffer) causes an enormous slowdown.
		
		#+BEGIN_SRC emacs-lisp
      (jiha-safe-require 'flyspell
                         ;; Create a ring of languages I would like to use
                         (progn (let ((langs '("american" "svenska" "norsk")))                 ;;(ref:dict_lang)
                                     (setq jiha-lang-ring (make-ring (length langs)))
                                     (dolist (elem langs) (ring-insert jiha-lang-ring elem)))
                                
                                ;; A function to easy switch between dictionaries using ring
                                ;; from above.
                                (defun jiha-cycle-ispell-languages ()                          ;;(ref:dict_func)
                                  (interactive)
                                  (let ((lang (ring-ref jiha-lang-ring -1)))
                                    (ring-insert jiha-lang-ring lang)
                                    (ispell-change-dictionary lang)))
                                
                                ;; smart function that will activate flyspell-mode or
                                ;; flyspell-prog-mode depending on mode of buffer. 
                                (defun jiha-flyspell-mode ()
                                  (interactive)
                                  (let ((text-modes '(org-mode))
                                        (prog-modes '(csharp-mode c++-mode c-mode lisp-mode)))
                                    (cond ((member major-mode text-modes)
                                           (if (and (boundp 'flyspell-mode) flyspell-mode)
                                               (flyspell-mode 0)
                                             (flyspell-mode 1)))
                                          ((member major-mode prog-modes)
                                           (if (and (boundp 'flyspell-mode) flyspell-mode)
                                               (flyspell-mode 0)
                                             (flyspell-prog-mode)))
                                          ;; default case
                                          (t 
                                           (if (and (boundp 'flyspell-mode) flyspell-mode)
                                               (flyspell-mode 0)
                                             (flyspell-mode 1))))))
                                                                  
                                ;; Fly-spell in C based programming modes
                                (add-hook 'c-mode-hook
                                          (lambda () (flyspell-prog-mode)))
                                
                                ;; Fly-spell in C++ based programming modes
                                (add-hook 'c++-mode-hook
                                          (lambda () (flyspell-prog-mode)))
                                
                                ;; Fly-spell in emacs-lisp mode
                                (add-hook 'lisp-mode-hook
                                          (lambda () (flyspell-prog-mode)))
                                
                                ;; easy access to flyspell/ispell functionality.
                                (global-set-key (kbd "<f8>")     'ispell-word)
                                (global-set-key (kbd "C-<f8>")   'jiha-flyspell-mode)
                                (global-set-key (kbd "S-<f8>")   'jiha-cycle-ispell-languages) ;;(ref:dict_cycle)
                                (global-set-key (kbd "C-M-<f8>") 'flyspell-buffer)
                                (global-set-key (kbd "C-S-<f8>") 'flyspell-check-previous-highlighted-word)
                                
                                (setq flyspell-issue-message-flag nil)))
      
		#+END_SRC        

***** Installing ispell on windows																								 :instw:
		To solve the problem with multiple languages we first need to define what languages
		we are interesting in switching between, if we don't do that the result will be that
		on systems with many dictionaries it will be to much of a problem switching. So first
		we create a ring of languages at [[(dict_lang)][let langs]], that ring is used by a function that will move
		from one language after another and that function is defined at [[(dict_func)][defun]], and at last
		we bind that function to a key-combo for easy access at [[(dict_cycle)][global-set...]]

***** Installing ispell on windows																								 :instw:

			look here and download everthing you need.
			http://aspell.net/win32/

			add aspell directory to path

*** Whitespace																															 :keybindings:

		I use whitespace mode a lot, maybe because I dont have configured the programming
		modes to "do the right thing" yet and some other programmers around me are experts at
		leaving trailing whitespaces and mixing tabs and spaces. <rant>the same persons
		ussally write really long lines to, and have 8 levels of indentation in the same
		method and uses indent depth of 4 or 8, I wonder how wide their screens are.</rant>

		#+BEGIN_SRC emacs-lisp
      ;; whitespace-mode things
      
      ;; less color in whitespace mode, The yellow and red is to distracting
      (setq whitespace-style (quote (spaces tabs newline space-mark 
                                            tab-mark newline-mark)))
      
      ;; make whitespace-mode use "" for newline and -> for tab.
      ;; together with the rest of its defaults
      (setq whitespace-display-mappings
            '(
              (space-mark 32 [183] [46]) ; normal space, ·
              (space-mark 160 [164] [95])
              (space-mark 2208 [2212] [95])
              (space-mark 2336 [2340] [95])
              (space-mark 3616 [3620] [95])
              (space-mark 3872 [3876] [95])
              (newline-mark 10 [8629 10]) ; newlne
              (tab-mark 9 [8677 9] [92 9]) ; tab
              ))
      
      ;; My own whitespace cleanup function should be bound to something.
      ;; or used in some save-hook don't know how this work together with smart-tabs
      (defun jiha-whitespace-cleanup ()
        (interactive)
        (let (whitespace-style '(indentation::tab 
                                 space-before-tab::tab
                                 trailing))
          (whitespace-cleanup-region)))
      
      (global-set-key (kbd "<f9>") 'whitespace-mode)
      (global-set-key (kbd "C-<f9>") 'jiha-whitespace-cleanup)
      (global-set-key (kbd "C-S-<f9>") 'whitespace-cleanup-region)
		#+END_SRC

*** Auto-complete

		#+BEGIN_SRC emacs-lisp
      ;; I should not need to add this to load path that should be
      ;; done by elpa magic.
      (add-to-list 'load-path "~/.emacs.d/elpa/popup-0.5")
      (add-to-list 'load-path "~/.emacs.d/elpa/auto-complete-1.4")
      ;;(require 'auto-complete)
      ;;(require 'auto-complete-config)
      ;;(add-to-list 'ac-dictionary-directories (concat local-emacs-org-dir 
      ;;                                                "ac-dicts"))
      ;;(ac-config-default)
      ;;(define-key ac-mode-map (kbd "M-TAB") 'auto-complete)
      ;;(ac-flyspell-workaround)
		#+END_SRC

*** Font-lock
*** Hl-Line

		Makes it easier to find current line i am on, it will highlight the current line if I
		am inactive for 5 seconds and turn it of as soon as I start typing.

		#+BEGIN_SRC emacs-lisp
      ;; normal hl-line is not good enough, we need some more functions, this add that.
      (jiha-safe-require 'hl-line+
                        (progn
                          ;; Only use hl-line when we are idle, as soon as I start typing it is removed and does
                          ;; then not interfere with my other faces.
                          (toggle-hl-line-when-idle 1)
                          
                          ;; If we need to remove hl-line for a specific mode, list them here.
                          ;; (setq hl-line-inhibit-highlighting-for-modes)      
                        
                          ;; we also needs to set an interval that tells us how long we need to idle before hl-line
                          ;; turns on
                          (hl-line-when-idle-interval 5)))
		#+END_SRC

*** Electric pair, indent.... mode
		
*** Show-Paren
		
		It is a global mode but I want it buffer local so first we make it buffer local then
		we setup a default that is off, then we will activate it in those major modes we want
		it in.

		then we add rainbow colors on nested parens

		(require 'highlight-parentheses) is one
		(require 'rainbow-delimiters) is another

		advice it so it tells me what row matching paren is when it is off-screen.
		#+BEGIN_SRC emacs-lisp
      ;; Only works sometime
      (defadvice show-paren-function
        (after show-matching-paren-offscreen disable)
        "If the matching paren is offscreen, show the matching line in the
        echo area. Has no effect if the character before point is not of
        the syntax class ')'."
        (interactive)
        (if (not (minibuffer-prompt))
            (let ((matching-text nil))
              ;; Only call `blink-matching-open' if the character before point
              ;; is a close parentheses type character. Otherwise, there's not
              ;; really any point, and `blink-matching-open' would just echo
              ;; "Mismatched parentheses", which gets really annoying.
              (if (char-equal (char-syntax (char-before (point))) ?\))
                  (setq matching-text (blink-matching-open)))
              (if (not (null matching-text))
                  (message matching-text)))))
      
		#+END_SRC
		
***** TODO Activate it in those major modes we want it in.
			- all programing-modes
			- org-mode

*** Pretty

		Its a mode for displaying lambda signs and other things in a nice way.

		#+BEGIN_SRC emacs-lisp
      ;; we should add pretty-symbols-mode to a bunch of mode hooks.
      (jiha-safe-require 'pretty-mode ())
		#+END_SRC

  #+RESULTS:

		now we need to configure what characters that should be used.

		#+BEGIN_src emacs-lisp
      (setq pretty-patterns
            (let* ((lispy '(scheme emacs-lisp lisp))
                   (mley '(tuareg haskell sml))
                   (c-like '(c c++ perl sh python java ess ruby csharp))
                   (all (append lispy mley c-like (list 'octave))))
              (pretty-compile-patterns
               `(
                 (?≠ ("!=" ,@c-like scheme octave)
                     ("<>" tuareg octave)
                     ("~=" octave)
                     ("/=" haskell emacs-lisp))
                 (?≤ ("<=" ,@all))
                 (?≥ (">=" ,@all))
                 (?← ("<-" ,@mley ess))
                 (?➛ ("->" ,@mley ess c c++ perl))
                 (?↑ ("\\^" tuareg))
                 (?⟹ ("=>" sml perl ruby))
                 (?∅ ("nil" emacs-lisp ruby)
                     ("null" scheme java csharp)
                     ("NULL" c c++)
                     ("()" ,@mley))
                 (?√ ("sqrt" ,@all))
                 (?∑ ("sum" python))
                 (?α ("alpha" ,@all)
                     ("'a" ,@mley))
                 (?β ("beta" ,@all)
                     ("'b" ,@mley))
                 (?γ ("gamma" ,@all)
                     ("'c" ,@mley))
                 (?Δ ("delta" ,@all)
                     ("'d" ,@mley))
                 (?ε ("epsilon" ,@all))
                 (?θ ("theta" ,@all))
                 (?λ ("lambda" ,@all)
                     ("fn" sml)
                     ("fun" tuareg)
                     ("\\" haskell))
                 (?π ("pi" ,@all)
                     ("M_PI" c c++))
                 (?φ ("psi" ,@all))

                 (?¹ ("**1" python tuareg octave)
                     ("^1" octave haskell)
                     ("^1" ,@c-like))
                 (?² ("**2" python tuareg octave)
                     ("^2" octave haskell)
                     ("^2" ,@c-like))
                 (?³ ("**3" python tuareg octave)
                     ("^3" octave haskell)
                     ("^3" ,@c-like))
                 (?⁴ ("**4" python tuareg octave)
                     ("^4" octave haskell)
                     ("^4" ,@c-like))
                 (?⁵ ("**5" python tuareg octave)
                     ("^5" octave haskell)
                     ("^5" ,@c-like))
                 (?⁶ ("**6" python tuareg octave)
                     ("^6" octave haskell)
                     ("^6" ,@c-like))
                 (?⁷ ("**7" python tuareg octave)
                     ("^7" octave haskell)
                     ("^7" ,@c-like))
                 (?⁸ ("**8" python tuareg octave)
                     ("^8" octave haskell)
                     ("^8" ,@c-like))
                 (?⁹ ("**9" python tuareg octave)
                     ("^9" octave haskell)
                     ("^9" ,@c-like))
                 (?ⁿ ("**n" python tuareg octave)
                     ("^n" octave haskell)
                     ("^n" ,@c-like))
                 (?ⁱ ("**i" python tuareg octave)
                     ("^i" octave haskell)
                     ("^i" ,@c-like))

                 (?₀ ("[0]" ,@c-like))
                 (?₁ ("[1]" ,@c-like))
                 (?₂ ("[2]" ,@c-like))
                 (?₃ ("[3]" ,@c-like))
                 (?₄ ("[4]" ,@c-like))
                 (?₅ ("[5]" ,@c-like))
                 (?₆ ("[6]" ,@c-like))
                 (?₇ ("[7]" ,@c-like))
                 (?₈ ("[8]" ,@c-like))
                 (?₉ ("[9]" ,@c-like))
                 
                 (?∞ ("HUGE_VAL" c c++))
                 
                 (?∧ ("&&"      c c++ perl haskell))
                 (?∨ ("||"      c c++ perl haskell))
                 (?¬ ("\\<!\\>" c c++ perl sh))
                 
                 (?ₐ ("[a]" ,@c-like))
                 (?ₑ ("[e]" ,@c-like))
                 (?ₕ ("[h]" ,@c-like))
                 (?ᵢ ("[i]" ,@c-like))
                 (?ⱼ ("[j]" ,@c-like))
                 (?ₖ ("[k]" ,@c-like))
                 (?ₗ ("[l]" ,@c-like))
                 (?ₘ ("[m]" ,@c-like))
                 (?ₙ ("[n]" ,@c-like))
                 (?ₒ ("[o]" ,@c-like))
                 (?ₚ ("[p]" ,@c-like))
                 (?ᵣ ("[r]" ,@c-like))
                 (?ₛ ("[s]" ,@c-like))
                 (?ₜ ("[t]" ,@c-like))
                 (?ᵤ ("[u]" ,@c-like))
                 (?ᵥ ("[v]" ,@c-like))
                 (?ₓ ("[x]" ,@c-like))
                 
                 (?∧ ("&&" c c++ csharp perl haskell))
                 (?∨ ("||" c c++ perl haskell))
                 (?¬ ("\\<!\\>" c c++ perl sh))))))

		#+END_src

  #+RESULTS:

***** DONE move my changes from pretty-mode.el to this file
			:LOGBOOK:
			- State "DONE"       from "TODO"       [2013-07-02 ti 23:45]
			CLOCK: [2013-07-02 ti 23:30]--[2013-07-02 ti 23:44] =>  0:14
			- moved my changes out from pretty-mode.el into this file, and replaced
        pretty-mode.el from emacswiki.
			:END:
*** Interaction log

		#+BEGIN_SRC emacs-lisp
      (require 'interaction-log)
      ;;(interaction-log-mode +1)
      
      (global-set-key [f1] (lambda () (interactive) (display-buffer ilog-buffer-name)))          
		#+END_SRC

  #+RESULTS:
	| lambda | nil | (interactive) | (display-buffer ilog-buffer-name) |
	
* Other Major Modes
* Iswitch Buffers																																 :buffers:

	To prevent certain buffers from showing up in the completion list, set
	'iswitchb-buffer-ignore': (setq iswitchb-buffer-ignore '("^ " "*Buffer")) This one is
	useful if you want to lose the *...* special buffers from the list. It's helpful if
	you're using the JDEE for editing Java apps, as you end up with buffers named
	org.whatever.package.Class which you might want to eliminate: (setq
	iswitchb-buffer-ignore '("^\\*")) To prevent switching to another frame, you can add the
	following to your configuration: (setq iswitchb-default-method 'samewindow)

	#+BEGIN_SRC emacs-lisp
    (iswitchb-mode 1)
    ;; rebind the normal key for buffer list to ibuffer
    (global-set-key (kbd "C-x C-b") 'ibuffer)
    (setq ibuffer-expert t)
    (setq ibuffer-show-empty-filter-groups nil)
    (setq iswitchb-default-method 'samewindow)
    ;; in your .emacs will allow left/right artist--arrow key navigation of the
    ;; buffer list, and deactivate up/down in iswitchb. Note that you
    ;; can by default use C-s and C-r to do this.  If the
    ;; below fails with "define-key: Symbol's function definition is
    ;; void: edmacro-parse-keys" you need to load the package defining
    ;; edmacro with (require 'edmacro).
    (defun iswitchb-local-keys ()
      (mapc (lambda (K) 
              (let* ((key (car K)) (fun (cdr K)))
                (define-key iswitchb-mode-map (edmacro-parse-keys key) fun)))
            '(("<right>" . iswitchb-next-match)
              ("<left>"  . iswitchb-prev-match)
              ("<up>"    . ignore             )
              ("<down>"  . ignore             ))))
    (add-hook 'iswitchb-define-mode-map-hook 'iswitchb-local-keys)
	#+END_SRC

 #+RESULTS:
 | iswitchb-local-keys |

	
	#+BEGIN_SRC emacs-lisp
    (add-hook 'ibuffer-mode-hook 
              '(lambda ()
                 (ibuffer-auto-mode 1)
                 (ibuffer-switch-to-saved-filter-groups "home")))
    
    ;; Switching to ibuffer puts the cursor on the most recent buffer
    (defadvice ibuffer (around ibuffer-point-to-most-recent) ()
      "Open ibuffer with cursor pointed to most recent buffer name"
      (let ((recent-buffer-name (buffer-name)))
        ad-do-it
        (ibuffer-jump-to-buffer recent-buffer-name)))
    (ad-activate 'ibuffer)
    
    (defun switch-buffers-between-frames ()
      "switch-buffers-between-frames switches the buffers between the two last frames"
      (interactive)
      (let ((this-frame-buffer nil)
            (other-frame-buffer nil))
        (setq this-frame-buffer (car (frame-parameter nil 'buffer-list)))
        (other-frame 1)
        (setq other-frame-buffer (car (frame-parameter nil 'buffer-list)))
        (switch-to-buffer this-frame-buffer)
        (other-frame 1)
        (switch-to-buffer other-frame-buffer))) 
	#+END_SRC

 #+RESULTS:
 : switch-buffers-between-frames

	#+BEGIN_SRC emacs-lisp
    ;; Use human readable Size column instead of original one
    (setq ibuffer-inline-columns ())
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000) (format "%7.2f Kb" (/ (buffer-size) 1000.0)))
       ((> (buffer-size) 1000000) (format "%7.2f Mb" (/ (buffer-size) 1000000.0)))
       (t (format "%8d b" (buffer-size)))))
    
    ;; Modify the default ibuffer-formats
    (setq ibuffer-formats
          '((mark modified read-only " "
                  (name 20 20 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  filename-and-process)
            (mark " "
                  (name 20 -1)
                  " " filename)))
	#+END_SRC

  #+RESULTS:
	| mark | modified | read-only    |   | (name 20 20 :left :elide) |   | (size-h 9 -1 :right) |   | (mode 16 16 :left :elide) |   | filename-and-process |
	| mark |          | (name 20 -1) |   | filename                  |   |                      |   |                           |   |                      |
	
	#+BEGIN_SRC emacs-lisp
    (setq ibuffer-saved-filter-groups
          '(("home"
             ("Emacs" (or (filename . ".emacs.d")
                          (filename . "emacs.org")
                          (filename . ".emacs")))
             ("Org" (or (filename . ".org")
                        (filename . "OrgMode")
                        (name . "*Org Agenda*")
                        (name . "diary")))
             ("code" (or (mode . csharp-mode)
                         (mode . c++-mode)
                         (mode . lisp-mode)
                         (mode . c-mode)))
             ("Web Dev" (or (mode . html-mode)
                            (mode . css-mode)))
             ("SQL" (or (filename . ".plb")
                        (filename . ".sql")
                        (filename . ".dbo")
                        (mode . sqli-mode)
                        (name . "*SQL*")))
             ("VC" (or (name . "\*svn")
                       (name . "\*magit")))
             ("ERC" (or (mode . erc-mode)
                        (mode . erc-list-mode)))
             ("gnus" (or
                      (mode . message-mode)
                      (mode . bbdb-mode)
                      (mode . mail-mode)
                      (mode . gnus-group-mode)
                      (mode . gnus-summary-mode)
                      (mode . gnus-article-mode)
                      (name . "^\\.bbdb$")
                      (name . "^\\.newsrc-dribble")))
             ("Custom" (mode . Custom-mode))
             ("Help" (or (name . "\*Help\*")
                         (name . "\*Apropos\*")
                         (name . "\*info\*"))))))
	 #+END_SRC

 #+RESULTS:
 | home | (Emacs (or (filename . .emacs.d) (filename . emacs.org) (filename . .emacs))) | (Org (or (filename . .org) (filename . OrgMode) (name . *Org Agenda*) (name . diary))) | (code (or (mode . csharp-mode) (mode . c++-mode) (mode . lisp-mode) (mode . c-mode))) | (Web Dev (or (mode . html-mode) (mode . css-mode))) | (SQL (or (filename . .plb) (filename . .sql) (mode . sqli-mode) (name . *SQL*))) | (VC (or (name . *svn) (name . *magit))) | (ERC (or (mode . erc-mode) (mode . erc-list-mode))) | (gnus (or (mode . message-mode) (mode . bbdb-mode) (mode . mail-mode) (mode . gnus-group-mode) (mode . gnus-summary-mode) (mode . gnus-article-mode) (name . ^\.bbdb$) (name . ^\.newsrc-dribble))) | (Custom (mode . Custom-mode)) | (Help (or (name . *Help*) (name . *Apropos*) (name . *info*))) |

	

*** Colours in buffer list																												 :faces:

		#+BEGIN_SRC emacs-lisp
      (setq ibuffer-fontification-alist
            '((1 (eq major-mode 'org-mode) (font-lock-keyword-face))
              (4 (eq buffer-file-name "~/diary") (font-lock-keywork-face)) ;; does not work??
              (2 (eq major-mode 'Custom-mode) (font-lock-preprocessor-face))
              (3 (eq major-mode 'erc-mode) (font-lock-string-face))))
		#+END_SRC

  #+RESULTS:
	| 1 | (eq major-mode (quote org-mode))    | (font-lock-keyword-face)      |
	| 4 | (eq buffer-file-name ~/diary)       | (font-lock-keywork-face)      |
	| 2 | (eq major-mode (quote Custom-mode)) | (font-lock-preprocessor-face) |
	| 3 | (eq major-mode (quote erc-mode))    | (font-lock-string-face)       |

*** Iswitch and uniquify compatibility																					:uniquify:

		The library uniquify overrides Emacs default mechanism for making buffer names unique
		(using suffixes like <2>, <3> etc.) with a more sensible behaviour which use parts of
		the file names to make the buffer names distinguishable.  Additionally one can
		configure uniquify to rework the buffer names whenever a buffer is killed. This
		feature does not play well with IswitchBuffers function iswitchb-kill-buffer, bound to
		C-k. The following code instructs iswitchb-kill-buffer to update the buffer list after
		killing a buffer, so that a possible buffer renaming by uniquify is taken in account.

		#+BEGIN_SRC emacs-lisp
      (defadvice iswitchb-kill-buffer (after rescan-after-kill activate)
        "*Regenerate the list of matching buffer names after a kill.
      Nextcessary if using `uniquify' with `uniquify-after-kill-buffer-p'
      set to non-nil."
        (setq iswitchb-buflist iswitchb-matches)
        (iswitchb-rescan))
      
      (defun iswitchb-rescan ()
        "*Regenerate the list of matching buffer names."
        (interactive)
        (iswitchb-make-buflist iswitchb-default)
        (setq iswitchb-rescan t))
		#+END_SRC

*** More Iswitch things that I don't use at the moment
		http://martinowen.net/blog/2010/02/tips-for-emacs-ibuffer.html
***** Keybindings

			Something most IswitchBuffers users aren't aware of is that you can hit C-k to kill
			the currently selected buffer.

***** Using Iswitch-Buffer Programmatically
			
			From: KinCho Subject: my-icompleting-read Newsgroups: gnu.emacs.sources Date: Tue,
			09 Oct 2001 16:28:18 GMT
			
			I used iswitchb for a while and really liked it. I began to explore to see if I can
			borrow iswitchb to make my scripts work like iswitchb as well. Well, it turned out
			iswitchb is coded in a way that makdes it really easy to borrow it to do regex-style
			completing-read:

			#+BEGIN_EXAMPLE emacs-lisp
        (defun my-icompleting-read(prompt choices) (let ((iswitchb-make-buflist-hook
        (lambda () (setq iswitchb-temp-buflist choices)))) (iswitchb-read-buffer prompt)))
			#+END_EXAMPLE

			Another example. Two things. "nil t" to iswitchb-read-buffer requires a choice from
			the given list with no default. Using an flet is a way to work when there's no hook
			variable. There is a hook variable.

			#+BEGIN_EXAMPLE emacs-lisp
        (defvar interesting (regexp-opt '(".c" ".h" "etc.")))  (defvar some-directory
        "/home/somewhere/etc/")
        
        ;; Ma king this more flexible is an exercise for the reader (defun find-a-file
        (arg &optional non-selective) "Select files using substrings."  (interactive
        "sFile: ") (let ((dir (expand-file-name some-directory)) candidates) (flet
        ((file-match (file) (if non-selective (string-match arg file) (and (string-match
        interesting file) (string-match arg file))))) (setq candidates (delq nil (loop for
        file in (directory-files dir) collect (if (file-match file) file))))) (cond ((eq
        (length candidates) 1) (find-file (format "%s%s" dir (car candidates)))) ((eq
        (length candidates) 0) (if non-selective (message "No such file!")  (find-a-file
        arg t))) (t (flet ((iswitchb-make-buflist (default) (setq iswitchb-buflist
        candidates))) (find-file (format "%s%s" dir (iswitchb-read-buffer "File: " nil
        t))))))))
			#+END_EXAMPLE
				
			I'm quite new to iswitchb. I've been after eliminating the need to confirm (with TAB
			or ret) the last left possibility.
				
			I've started with this simple hack, which only displays the desired buffer, but in
			this way, i don't need to look at the minibuffer (in some cases).
			
			#+BEGIN_EXAMPLE emacs-lisp
        (defun iswitchb-post-command () "Run after command in 'iswitchb-buffer'."
        (iswitchb-exhibit) (if (= (length iswitchb-matches) 1) (display-buffer (car
        iswitchb-matches))))
			#+END_EXAMPLE
			
			another thing i like, is to have the freedom to decide to open the buffer in
			other-window/frame after i made the selection: Hence a new minibuffer exiting
			command:
			
			#+BEGIN_EXAMPLE emacs-lisp
        (defun iswitchb-select-buffer-other-window () "Select the buffer named by the
        prompt. But in another window."  (interactive) (setq iswitchb-method 'otherwindow)
        (exit-minibuffer))
			#+END_EXAMPLE
			
			The functionality of iswitchb can also be used to provide a replacement for the
			usual behaviour of find-file. Instead of hitting Tab to bring up a buffer listing
			the possible file completions, a list of file completions is continuously updated in
			the minibuffer:
			
			#+BEGIN_EXAMPLE emacs-lisp
        (defun exd-find-file () "Use functionality from `iswitchb' as a replacement for
        `find-file'" (interactive) (find-file (exd-iswitchb-find-file "." (directory-files
        "."))))
        
        (defun exd-iswitchb-find-file (dir file-list) "Use functionality from `iswitchb'
        to select a file for `find-file'.  If a directory is selected, enter that
        directory and generate a new list from which to select a file."  ;; sort the file
        list into directories first (setq file-list (sort file-list (lambda (elt-1 elt-2)
        (and (file-directory-p (concat dir "/" elt-1)) (not (file-directory-p (concat dir
        "/" elt-2))))))) ;; use iswitchb for minibuffer file list/completion magic (let*
        (resize-mini-windows (iswitchb-make-buflist-hook (lambda () (setq
        iswitchb-temp-buflist file-list))) ;; get the selected file (selected-file (concat
        dir "/" (iswitchb-read-buffer (concat "Find File: " (expand-file-name dir)
        "/"))))) ;; if the selected file is a directory, recurse, else return file (if
        (file-directory-p selected-file) (exd-iswitchb-find-file selected-file
        (directory-files selected-file)) selected-file)))
			#+END_EXAMPLE
			
			See Also:
			
			Icicles, and command 'icicle-buffer', which is similar to 'iswitchb-buffer' but
			provides some additional features. Also, Icicles treats all types of minibuffer
			input the same way: filenames, buffer names, commands, variables...everything. And
			it lets you use a regexp to match completions, if you like.  InteractivelyDoThings
			(ido), which implements regex selection for files, directory buffers etc...

* Buffer Menu
*** Font lock																																		:fontlock:

		If you use ElectricBufferList, then simply use this instead for the last line:
		(add-hook 'electric-buffer-menu-mode-hook 'buffer-menu-custom-font-lock)
		
		need to put the right colors on this.
		#+BEGIN_SRC emacs-lisp
      (setq buffer-menu-buffer-font-lock-keywords '(("^....[*]Man .*Man.*" . font-lock-variable-name-face) ;Man page 
                                                    (".*Dired.*" . font-lock-comment-face) ; Dired 
                                                    ("^....[*]shell.*" . font-lock-preprocessor-face) ; shell buff 
                                                    (".*[*]scratch[*].*" . font-lock-function-name-face) ; scratch buffer 
                                                    ("^....[*].*" . font-lock-string-face) ; "*" named buffers 
                                                    ("^..[*].*" . font-lock-constant-face) ; Modified 
                                                    ("^.[%].*" . font-lock-keyword-face))) ; Read only
      
      (defun buffer-menu-custom-font-lock () 
        (let ((font-lock-unfontify-region-function
               (lambda (start end) 
                 (remove-text-properties start end '(font-lock-face nil)))))
          (font-lock-unfontify-buffer) 
          (set (make-local-variable 'font-lock-defaults)
               '(buffer-menu-buffer-font-lock-keywords t)) 
          (font-lock-fontify-buffer)))
      
      (add-hook 'buffer-menu-mode-hook 'buffer-menu-custom-font-lock)
		 #+END_SRC

* Coding
  Here I will place everything that has todo with coding

*** Languages modes
***** Haskell
			#+BEGIN_SRC emacs-lisp
        (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
        
        ;; only one of these 3 below should be used at one time
        ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
        (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
        ;;(add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
        
        ;; support for inferior haskell shell
        ;;(add-hook 'haskell-mode-hook (lambda (jiha-safe-require 'inf-haskell ())))
        
        ;; keep my files looking good
        (setq haskell-stylish-on-save t)
        
        ;; alignment rules
        ;; (add-to-list 'align-rules-list
        ;;              '(haskell-types
        ;;                (regexp . "\\(\\s-+\\)\\(::\\|∷\\)\\s-+")
        ;;                (modes quote (haskell-mode literate-haskell-mode))))
        ;; (add-to-list 'align-rules-list
        ;;              '(haskell-assignment
        ;;                (regexp . "\\(\\s-+\\)=\\s-+")
        ;;                (modes quote (haskell-mode literate-haskell-mode))))
        ;; (add-to-list 'align-rules-list
        ;;              '(haskell-arrows
        ;;                (regexp . "\\(\\s-+\\)\\(->\\|→\\)\\s-+")
        ;;                (modes quote (haskell-mode literate-haskell-mode))))
        ;; (add-to-list 'align-rules-list
        ;;              '(haskell-left-arrows
        ;;                (regexp . "\\(\\s-+\\)\\(<-\\|←\\)\\s-+")
        ;;                (modes quote (haskell-mode literate-haskell-mode))))
			#+END_SRC

			#+BEGIN_SRC emacs-lisp
        ;; this might allready be in haskell mode, else i should move it to pretty-mode
        
        (defun unicode-symbol (name)
          "Translate a symbolic name for a Unicode character -- e.g., LEFT-ARROW or GREATER-THAN into an actual Unicode character code. "
          (decode-char 'ucs (case name                                             
                              (left-arrow 8592)
                              (up-arrow 8593)
                              (right-arrow 8594)
                              (down-arrow 8595)                                                
                              (double-vertical-bar #X2551)                  
                              (equal #X003d)
                              (not-equal #X2260)
                              (identical #X2261)
                              (not-identical #X2262)
                              (less-than #X003c)
                              (greater-than #X003e)
                              (less-than-or-equal-to #X2264)
                              (greater-than-or-equal-to #X2265)                        
                              (logical-and #X2227)
                              (logical-or #X2228)
                              (logical-neg #X00AC)                                                  
                              ('nil #X2205)
                              (horizontal-ellipsis #X2026)
                              (double-exclamation #X203C)
                              (prime #X2032)
                              (double-prime #X2033)
                              (for-all #X2200)
                              (there-exists #X2203)
                              (element-of #X2208)              
                              (square-root #X221A)
                              (squared #X00B2)
                              (cubed #X00B3)                                            
                              (lambda #X03BB)
                              (alpha #X03B1)
                              (beta #X03B2)
                              (gamma #X03B3)
                              (delta #X03B4))))
        (defun substitute-pattern-with-unicode (pattern symbol)
          "Add a font lock hook to replace the matched part of PATTERN with the Unicode symbol SYMBOL looked up with UNICODE-SYMBOL."
          (font-lock-add-keywords
           nil `((,pattern 
                (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                          ,(unicode-symbol symbol)
                                          'decompose-region)
                          nil))))))
        (defun substitute-patterns-with-unicode (patterns)
          "Call SUBSTITUTE-PATTERN-WITH-UNICODE repeatedly."
          (mapcar #'(lambda (x)
                      (substitute-pattern-with-unicode (car x)
                                                       (cdr x)))
                  patterns))
        
        (defun haskell-unicode ()
          (substitute-patterns-with-unicode
           (list (cons "\\(<-\\)" 'left-arrow)
                 (cons "\\(->\\)" 'right-arrow)
                 (cons "\\(==\\)" 'identical)
                 (cons "\\(/=\\)" 'not-identical)
                 (cons "\\(()\\)" 'nil)
                 (cons "\\<\\(sqrt\\)\\>" 'square-root)
                 (cons "\\(&&\\)" 'logical-and)
                 (cons "\\(||\\)" 'logical-or)
                 (cons "\\<\\(not\\)\\>" 'logical-neg)
                 (cons "\\(>\\)\\[^=\\]" 'greater-than)
                 (cons "\\(<\\)\\[^=\\]" 'less-than)
                 (cons "\\(>=\\)" 'greater-than-or-equal-to)
                 (cons "\\(<=\\)" 'less-than-or-equal-to)
                 (cons "\\<\\(alpha\\)\\>" 'alpha)
                 (cons "\\<\\(beta\\)\\>" 'beta)
                 (cons "\\<\\(gamma\\)\\>" 'gamma)
                 (cons "\\<\\(delta\\)\\>" 'delta)
                 (cons "\\(''\\)" 'double-prime)
                 (cons "\\('\\)" 'prime)
                 (cons "\\(!!\\)" 'double-exclamation)
                 (cons "\\(\\.\\.\\)" 'horizontal-ellipsis))))
        
        ;;(add-hook 'haskell-mode-hook 'haskell-unicode)
        
        ;; instead we try this
        ;; at least I have documenation for the variable, that should mean it works.
        (setq haskell-font-lock-symbols t)
			#+END_SRC
***** PLSQL
			
			#+BEGIN_SRC emacs-lisp
      	;;(jiha-safe-require 'plsql ())
			#+END_SRC
***** SQL-mode

			First we need to associate oracles sql files with sql-mode, and deactiveate
			linewrapping, it's idiotic in sqli-mode

			#+BEGIN_SRC emacs-lisp
        (add-to-list 'auto-mode-alist '("\\.plb\\'" . sql-mode))
        (add-hook 'sql-interactive-mode-hook (lambda ()
                                               (toggle-truncate-lines 1)))
        (add-hook 'sql-interactive-mode-hook (lambda ()
                                               (setq comint-input-ring-name
                                                     (concat (sql-make-alternate-buffer-name)
                                                             ".history"))))
			#+END_SRC

   #+RESULTS:
	 | (lambda nil (setq comint-input-ring-name (concat (sql-make-alternate-buffer-name) .history))) | sql-rename-buffer | (lambda nil (toggle-truncate-lines 1)) |

******* Support Multiple connections

				If you work with multiple connections, you need to rename them such that the next
				sql-foo command creates a new SQL buffer instead of popping you to the existing
				one. Use M-x sql-rename-buffer for that, or the SQL menu entry. To do it
				autmatically, after every connection, use the following in your ~/.emacs file: 

				#+BEGIN_SRC emacs-lisp
        	(add-hook 'sql-interactive-mode-hook 'sql-rename-buffer)
				#+END_SRC

				Sometimes you can change the connection parameters, however. In Oracle, for example, you would to it as follows:
				
    		#+BEGIN_EXAMPLE
        	connect vdb/vdb@vdbdev;     
    		#+END_EXAMPLE

				This does not set ‘sql-alternate-buffer-name’, so a subsequent renaming will not
				produce a new name. Subsequent connections will also not provide the correct default
				parameters. Here is an Oracle-specific solution, including an automatic renaming of
				the buffer: 
				
				
				#+BEGIN_EXAMPLE emacs-lisp
        	(defun my-sql-connect-watch (line)
          	"Watch for connect statements and set variables accordingly.
        	Add this to `comint-input-filter-functions'."
          	(set-text-properties 0 (length line) nil line)
          	(when (string-match "connect \\([a-z_]+\\)/\\([a-z_]+\\)@\\([a-z_]+\\)" line)
            	(setq sql-user (match-string 1 line)
                  	sql-password (match-string 2 line)
                  	sql-database (match-string 3 line)
                  	sql-alternate-buffer-name (sql-make-alternate-buffer-name))
            	(sql-rename-buffer)))
        	(add-to-list 'comint-input-filter-functions 'my-sql-connect-watch)
				#+END_EXAMPLE

******* SQL-Plus support

				#+BEGIN_EXAMPLE emacs-lisp
        	(jiha-safe-require 'sqlplus ())
				#+END_EXAMPLE
				
******* Remove linenumbers from sqlplus output

				SQL*Plus has an interesting feature: Whenever you type a line of input, SQL*Plus
				adds a line number to the beginning of the next line. This line number is not part
				of the SQL command; it just allows you to refer to and edit specific lines in your
				SQL command. SQL*Plus acts like the standard text editor. SQL*Plus is on the
				TheTruePath. 

				This may make SQL*Plus error reporting less comprehensible when using SqlMode. Here
				is an example of the line number junk: 

				#+BEGIN_EXAMPLE
        	...
          	2    3    4       from v$parameter p, all_tables u
                  	*
        	ERROR at line 2:
        	ORA-00942: table or view does not exist     
				#+END_EXAMPLE
				This only happens if you enter multi-line SQL statements by using C-j instead of RET
				between lines (ie. using sql-accumulate-and-indent instead of comint-send-input). If
				you enter SQL statements one at a time, you’ll be fine. 

				The following elisp function must be added to comint-preoutput-filter-functions in
				order to strip the line numbers junk from the output: 

				#+BEGIN_EXAMPLE emacs-lisp
        	(defun eat-sqlplus-junk (str)
          	"Eat the line numbers SQL*Plus returns.
        	Put this on `comint-preoutput-filter-functions' if you are
        	running SQL*Plus.
        	If the line numbers are not eaten, you get stuff like this:
        	...
          	2    3    4       from v$parameter p, all_tables u
                  	*
        	ERROR at line 2:
        	ORA-00942: table or view does not exist
        	The mismatch is very annoying."
          	(interactive "s")
          	(while (string-match " [ 1-9][0-9]  " str)
            	(setq str (replace-match "" nil nil str)))
          	str)
				#+END_EXAMPLE
				Test it by evaluating the following expression:

				#+BEGIN_EXAMPLE
        	(string= "     from" (eat-sqlplus-junk "  2    3    4       from"))
				#+END_EXAMPLE

				Install it by adding the following expression to your .emacs; it will check wether
				the iSQL mode you have just started is indeed running SQL*Plus, and if it is, it
				will add eat-sqlplus-junk to comint-preoutput-filter-functions. 

				#+BEGIN_EXAMPLE emacs-lisp
        	(defun install-eat-sqlplus-junk ()
          	"Install `comint-preoutput-filter-functions' if appropriate.
            	Add this function to `sql-interactive-mode-hook' in your .emacs:
            	\(add-hook 'sql-mode-hook 'install-eat-sqlplus-junk)"
          	(if (string= (car (process-command (get-buffer-process sql-buffer)))
                       	 sql-oracle-program)
              	(add-to-list 'comint-preoutput-filter-functions
                           	 'eat-sqlplus-junk)))

        	(add-hook 'sql-interactive-mode-hook 'install-eat-sqlplus-junk)        
				#+END_EXAMPLE
******* new sql send buffer that works on windows

				there is some problem with buffering on windows and large buffers, even regions.
				read more at http://www.emacswiki.org/emacs/OracleOnWindows to solve this we will
				try to make a function that instead of pasting the content of the buffer into
				interactive sql session will try to just paste in @<filename>. that could solve
				the problem, I usually don't use the send region, but in that case i have to keep
				it under 500 chars to be safe.

				The drawback of this way of doing things is that the buffer need to be saved
				before sending it, or else we will send old content. this inhibit a workflow
				where you change some lines, tries if it works, maybe change some more. and when
				done you save. Or you just stop and bury the buffer to start out fresh but I
				usually use a VC for all my files and can use that as restore point.

				#+BEGIN_SRC emacs-lisp
          (defun jiha-send-sql-buffer () 
            "Easy fix around the problem on windows that comint does deadlock when trying 
          send big buffers to sqlplus. this instead sends the filename + path as a script 
          to be read and executed by sqlplus self. as long as path does not exeed ~500 it 
          should not be a problem."
            (interactive)
            (let ((current-buffer (current-buffer))
                  (dest-buffer sql-buffer))
              (progn
                (with-current-buffer dest-buffer
                  (insert (concat "@" (buffer-file-name current-buffer)))
                  (comint-send-input nil t)))))
				#+END_SRC
				
				The command to send the buffer to the sql session is bound to a key in sql mode
				and also exist in the menu, changing both these places are hard and therefor I
				opted for instead advicing the sql-send-buffer function that is used by both key
				combo and the menu item.

				#+BEGIN_SRC emacs-lisp
          (defadvice sql-send-buffer (around around-sql-send-buffer)
            "With the help of a around advice we trap calls to sql-send-buffer and instead replace
            them with call to my own function."
            (jiha-send-sql-buffer))
				#+END_SRC

******* Placeholder support in sql querys

				#+BEGIN_EXAMPLE emacs-lisp
        	(eval-after-load "sql"
          	'(load-library "sql-with-placeholders"))
        	(add-hook 'sql-mode-hook (lambda nil
                                   	 (local-set-key [(control c) (control b)] 
                                                  	'sql-send-buffer-with-placeholders)
                                   	 (local-set-key [(control c) (control c)] 
                                                  	'sql-send-paragraph-with-placeholders)
                                   	 (local-set-key [(control c) (control r)] 
                                                  	'sql-send-region-with-placeholders)))
        	
				#+END_EXAMPLE
***** nXML
			:LOGBOOK:
    	CLOCK: [2013-03-17 sö 12:08]--[2013-03-17 sö 12:23] =>  0:15
    	:END:

			First we need a local place to store all relax ng files used to validate and provide
			completion, that is synced between machines.
			
			#+BEGIN_SRC emacs-lisp
      	;; nxml is a part of the emacs distrobution so we don't need to have (when (require
      	;; .... 'noerror) around it, but we need to eval-after-load so the variable are
      	;; defined. 
      	
      	(eval-after-load "nxml-mode" 
        	'(add-to-list 'rng-schema-locating-files
                      	(concat local-emacs-org-dir "xml-schemas/schemas.xml")))
    	#+END_SRC

			We want completion and other fun stuff

			#+BEGIN_SRC emacs-lisp
      	;; just writing </ should be enaough to close last tag
      	;; ctrl tab to complete, this will do until we fixes w32 special keys things.
      	(eval-after-load "nxml-mode"
        	'(progn (setq nxml-slash-auto-complete-flag t)
                	(define-key nxml-mode-map (kbd "C-<tab>") 'nxml-complete)))
    	#+END_SRC

			#+BEGIN_SRC emacs-lisp
        (add-to-list 'auto-mode-alist '("\\.html$" . nxml-mode))
        (add-to-list 'auto-mode-alist '("\\.rng$" . nxml-mode))
        (add-to-list 'auto-mode-alist '("\\.rss$" . nxml-mode))
        (add-to-list 'auto-mode-alist '("\\.sch$" . nxml-mode))
        (add-to-list 'auto-mode-alist '("\\.svg$" . nxml-mode))
        (add-to-list 'auto-mode-alist '("\\.wsdl$" . nxml-mode))
        (add-to-list 'auto-mode-alist '("\\.xml$" . nxml-mode))
        (add-to-list 'auto-mode-alist '("\\.xsd$" . nxml-mode))
        (add-to-list 'auto-mode-alist '("\\.xsl$" . nxml-mode))
        (add-to-list 'auto-mode-alist '("\\.xslt$" . nxml-mode))
			#+END_SRC
******* TODO support validation
				http://www.emacswiki.org/emacs/XmlSchemaValidationWindows
******* Tools used for convertering to RelaxNG
				- http://debeissat.nicolas.free.fr/XSDtoRNG.php :: can be used to convert from XSD
             to RelaxNG that nXML uses, web-based
				- https://code.google.com/p/jing-trang/ :: also a tool for converting between
					 	 RelaxNG and other formats, you need java installed, commandline.
					 	 #+BEGIN_EXAMPLE
             	 #>java -jar tranq.jar
             	 usage: java com.thaiopensource.relaxng.translate.Driver [-C catalogFileOrUri] [-
             	 I rng|rnc|dtd|xml] [-O rng|rnc|dtd|xsd] [-i input-param] [-o output-param] input
             	 FileOrUri ... outputFile
					 	 #+END_EXAMPLE
******* links
				- howto specify things in schemas.xml ::
             http://www.dpawson.co.uk/relaxng/nxml/schemaloc.html

***** C#

			#+BEGIN_SRC emacs-lisp
        (defun maybe-csharp-style ()
          (when (and buffer-file-name
                     (string-match ".cs" buffer-file-name))
            (c-set-style "c#")))
        
        (add-hook 'c-mode-hook 'maybe-chsarp-style)

			#+END_SRC

			OmniSharp is a new tool to help with C# development it's a little daemon that stays
			in the background and emacs makes calls to it by using curl, so you also need ot
			install curl. OmniSharp has good completion at point and other goodies.
			
			we should make a csharp-mode-hook that activates it and sets up keybindings.
			#+BEGIN_SRC emacs-lisp
        (add-hook 'csharp-mode-hook 'omnisharp-mode)
        (eval-after-load 'company
          '(add-to-list 'company-backends 'company-omnisharp))
			#+END_SRC

******* TODO make it call msbuild in the right way, when building solutions.
				:LOGBOOK:
				CLOCK: [2013-10-02 on 19:55]--[2013-10-03 to 00:20] =>  4:25
				:END:
******* TODO Make it able to start and control what solution is used.
***** Lisp
			
			#+BEGIN_SRC emacs-lisp
        (require 'slime-autoloads)
        (load (expand-file-name "~/quicklisp/slime-helper.el"))
        (setq inferior-lisp-program "sbcl --noinform")
			#+END_SRC

   #+RESULTS:
	 : sbcl --noinform

*** Flymake
***** Haskell
			#+BEGIN_SRC emacs-lisp
        (jiha-safe-require 'flymake-haskell-multi
                           (add-hook 'haskell-mode-hook 'flymake-haskell-multi-load))
        
			#+END_SRC

			#+RESULTS:
			| flymake-haskell-multi-load | (lambda (jiha-safe-require (quote inf-haskell) nil)) | turn-on-haskell-indent | turn-on-haskell-doc-mode |

***** Flymake Cursor

			The normal operation of flymake allows the user to see the error message for a
			particular line by “hovering” the mouse over the line. This is inconvenient for
			people who try to use the keyboard for all input. FlymakeCursor was designed to
			address that: it displays the flymake error in the minibuffer region, when the
			cursor is placed on a line containing a flymake error.

			This works in any language that flymake supports

      #+BEGIN_SRC emacs-lisp 
        ;; we will active this when I have a configuration that will work on both windows and linux.
        ;;(load-file (concat local-emacs-org-dir "flymake-cursor.el"))
      #+END_SRC
*** Compile																																	 :keybindings:

		#+BEGIN_SRC emacs-lisp
      (jiha-safe-require 'compile 
                         (progn
                           ;; this means hitting the compile button always saves the buffer
                           ;; having to separately hit C-x C-s is a waste of time
                           (setq mode-compile-always-save-buffer-p t)
                           ;; make the compile window stick at 12 lines tall
                           (setq compilation-window-height 12)
                           
                           ;; from enberg on #emacs
                           ;; if the compilation has a zero exit code, 
                           ;; the windows disappears after two seconds
                           ;; otherwise it stays
                           (setq compilation-finish-function
                                 (lambda (buf str)
                                   (unless (string-match "exited abnormally" str)
                                     ;;no errors, make the compilation window go away in a few seconds
                                     (run-at-time
                                      "3 sec" nil 'delete-windows-on
                                      (get-buffer-create "*compilation*"))
                                     (message "No Compilation Errors!"))))
                           
                           ;; one-button testing, tada!
                           (global-set-key [f12] 'compile)))
		#+END_SRC

		#+RESULTS:
		: compile

		here is an example on how to use it together with local variables in a file

		#+BEGIN_SRC haskell
      -- haskell 2010 version
      import Test.HUnit
      import System.Exit
       
      myTestList = 
          TestList [
                    "add numbers" ~: 5 ~=? (3 + 2)
                   ,"add numbers" ~: 5 ~=? (3 + 3)
                   ]
       
      h = runTestTT myTestList
       
      main = do c <- h
                putStr $ show c
                let errs = errors c
                    fails = failures c
                exitWith (codeGet errs fails)
       
      codeGet errs fails
       | fails > 0       = ExitFailure 2
       | errs > 0        = ExitFailure 1
       | otherwise       = ExitSuccess
       
      -- Local Variables:
      -- compile-command: "ghc --make -o test  test.hs && ./test"
      -- End:
		#+END_SRC
		#+BEGIN_EXAMPLE 
		
		#+END_EXAMPLE

*** Coding styles
		:LOGBOOK:
    - State "DONE"       from "TODO"       [2012-10-11 Thu 22:35]
    :END:
		check out [[wiki:IndentingC#toc2][emacswiki on indenting]]
***** Microsoft C & C++ style

			Here is a style that pretty much matches the observed style of
			Microsoft (R)'s C and C++ code.

			#+BEGIN_SRC emacs-lisp
        (c-add-style "microsoft"
                     '("stroustrup"
                       (c-offsets-alist
                        (innamespace . -)
                        (inline-open . 0)
                        (inher-cont . c-lineup-multi-inher)
                        (arglist-cont-nonempty . +)
                        (template-args-cont . +))))
        
			#+END_SRC

***** OpenBSD style

			Style for OpenBSD? source code, also valid for OpenSSH? and other
			BSD based OSs source.

			#+BEGIN_SRC emacs-lisp
        (c-add-style "openbsd"
                     '("bsd"
                       (indent-tabs-mode . t)
                       (defun-block-intro . 8)
                       (statement-block-intro . 8)
                       (statement-case-intro . 8)
                       (substatement-open . 4)
                       (substatement . 8)
                       (arglist-cont-nonempty . 4)
                       (inclass . 8)
                       (knr-argdecl-intro . 8)))
			#+END_SRC
***** Google C++ Style

			This is the C++ style that I personaly finds to be best.

			#+BEGIN_SRC emacs-lisp
        (jiha-safe-require 'google-c-style ())
			#+END_SRC

*** Visual Studio Integration

		The only integration I have with visual studio at the moment is that I configure
		visual studio to have a shortcut for opening a file in emacs by using calls to
		emacsclientw.

*** CEDET
*** ECB
*** Completion
***** Language
******* C#
				
				#+BEGIN_SRC emacs-lisp
          (add-to-list 'load-path (concat local-emacs-org-dir "csharp"))
				#+END_SRC

				The `cscomp-assembly-search-paths' should hold a list of directories to search for
				assemblies that get referenced via using clauses in the modules you edit. This
				will try default to something reasonable, including the "typical" .NET 2.0 and 3.5
				directories, as well as the default locations for reference assemblies.  If you
				have non-default locations for these things, you should set them here. Also, if
				you have other libraries (for example, the WCF Rest Starter kit, or the Windows
				Automation assemblies) that you reference within your code, you can include the
				appropriate directory in this list.
			 
				#+BEGIN_EXAMPLE emacs-lisp
          (eval-after-load "csharp-completion"
           '(progn
              (setq cscomp-assembly-search-paths
                (list "c:\\.net3.5ra"    ;; <<- locations of reference assemblies
                      "c:\\.net3.0ra"    ;; <<-
                      "c:\\.net2.0"      ;; <<- location of .NET Framework assemblies
                      "c:\\.net3.5"      ;; <<- ditto
              ))))
				#+END_EXAMPLE

				#+BEGIN_SRC emacs-lisp
          ;;(csharp-analysis-mode 1)
          ;;(local-set-key "\M-\\"   'cscomp-complete-at-point)
          ;;(local-set-key "\M-§."   'cscomp-complete-at-point- ;; only on windows do we use csharp
          ;;(add-to-list 'csharp-mode-hook
          ;;             'jiha-csharp-mode-hook)
          (jiha-safe-require 'powershell
                            (jiha-safe-require 'csharp-completion 
                                              (defun jiha-csharp-mode-hook  
                                                ;; C# code completion
                                                (load-file (concat local-emacs-org-dir 
                                                                   "csharp/csharp-completion.el")))))
          
				#+END_SRC

******* CANCELLED ASPX
				:LOGBOOK:
				- State "CANCELLED"  from "TODO"       [2013-04-25 to 23:11]
				:END:
				this requires multi-mode which I don't have at the moment.

				#+BEGIN_EXAMPLE emacs-lisp
          (jiha-safe-require 'aspx-mode nil ())
				#+END_EXAMPLE
*** Indentation

		I usually use tabs for indentation and spaces for alignment, Emacs are one of the few
		envirement that support that kind of thing. I like a low c-basic-offset 2

		#+BEGIN_SRC emacs-lisp
      ;; use tabs for indentation later we setup spaces for alignment.
      (setq-default indent-tabs-mode t)
      ;; I want as much as possible on my screens.
      (setq-default c-basic-offset 2)
      (setq-default tab-width 2) ; or any other preferred value
		#+END_SRC

		This can be hard for other to replicate in there enviroment, If they are using
		VisualStudio the need Resharper to replicate this behavior. The could do without
		resharper and set VS to ident with tabs and manually align things with spaces when
		needed.

		#+BEGIN_SRC emacs-lisp
      ;; smart tabs, tabs for indentation, spaces for alignment
      (defadvice align (around smart-tabs activate)
        (let ((indent-tabs-mode nil)) ad-do-it))
      
      (defadvice align-regexp (around smart-tabs activate)
        (let ((indent-tabs-mode nil)) ad-do-it))
      
      (defadvice indent-relative (around smart-tabs activate)
        (let ((indent-tabs-mode nil)) ad-do-it))
      
      (defadvice indent-according-to-mode (around smart-tabs activate)
        (let ((indent-tabs-mode indent-tabs-mode))
          (if (memq indent-line-function
                    '(indent-relative
                      indent-relative-maybe))
              (setq indent-tabs-mode nil))
          ad-do-it))
      
      (defmacro smart-tabs-advice (function offset)
        `(progn
           (defvaralias ',offset 'tab-width)
           (defadvice ,function (around smart-tabs activate)
             (cond
              (indent-tabs-mode
               (save-excursion
                 (beginning-of-line)
                 (while (looking-at "\t*\\( +\\)\t+")
                   (replace-match "" nil nil nil 1)))
               (setq tab-width tab-width)
               (let ((tab-width fill-column)
                     (,offset fill-column)
                     (wstart (window-start)))
                 (unwind-protect
                     (progn ad-do-it)
                   (set-window-start (selected-window) wstart))))
              (t
               ad-do-it)))))
      
      (smart-tabs-advice c-indent-line c-basic-offset)
      (smart-tabs-advice c-indent-region c-basic-offset)
      ;; smart tabs - end
		#+END_SRC

***** SQL

		  #+BEGIN_SRC emacs-lisp
        ;;(eval-after-load "sql"
        ;;  '(load-library "sql-indent"))
			#+END_SRC
* Org-Mode
*** Basic
		
		A large part of the configuration has to do with how org should behave. it's a pretty
		complex mode with lot of things you could change. I have tried to make it as simple a
		possible with sub-trees for every main function of OrgMode.
		
		#+BEGIN_SRC emacs-lisp
      (setq org-deadline-warning-days 14)
      (setq org-timeline-show-empty-dates t)
      (setq org-feed-alist)
      (setq org-odd-levels-only t)
      (setq org-cycle-separator-lines 0)
      (setq org-enforce-todo-dependencies t)
      (setq org-use-fast-todo-selection t)
      (setq org-treat-S-cursor-todo-selection-as-state-change nil)
      (setq org-tags-column -90)
      (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
      (setq org-insert-mode-line-in-empty-file t)
      (jiha-safe-require 'org-crypt ())
      (org-crypt-use-before-save-magic)
      (setq org-tags-exclude-from-inheritance '("crypt"))
      (run-at-time "00:59" 3600 'org-save-all-org-buffers)
      (jiha-safe-require 'org-protocol ())
      (setq org-capture-use-agenda-date t)
      (setq org-columns-ellipses "…")
      (setq org-fontify-done-headline t)
      (setq org-footnote-auto-label (quote confirm))
      (setq org-goto-interface (quote outline-path-completion))
      (setq org-hidden-keywords (quote (author email title)))
      (setq org-hide-leading-stars t)
      (setq org-toc-default-depth 3)
      (setq org-toc-follow-mode t)
		#+END_SRC

		#+RESULTS:
		: t

		we need this in newer org-mode for some reason or everthing I write will be interpret
		as a list item and will give warnings.
		
		#+BEGIN_SRC emacs-lisp
      (setq org-list-allow-alphabetical t)
		#+END_SRC
*** newer org-mode needs newer outline 																		 :FIX:TEMPORARY:
		
		org-mode maintaners are using newer outline.el, where show-all has been renamed to
		outline-show-all, this solves that problem.

		#+BEGIN_SRC emacs-lisp
      (unless (boundp 'outline-show-all)
        (defun outline-show-all ()
          (interactive)
          (show-all)))
		#+END_SRC

  #+RESULTS:
	: outline-show-all

*** Global Keys for OrgMode																									 :keybindings:
		
		#+BEGIN_SRC emacs-lisp
      ;; org-mode Links
      ;; insert links should not really be global but what the hell.
      (global-set-key (kbd "S-<f5>") 'org-insert-link)
      (global-set-key (kbd "<f5>")   'org-store-link)
      
      ;; Agenda
      (global-set-key (kbd "S-<f6>") 'org-agenda)
      (global-set-key (kbd "<f6>") 'org-agenda-list)
			(global-set-key (kbd "C-<f6>") 'org-todo-list)
      
      ;; capture
      ;; ask me what type of item to capture
      (global-set-key (kbd "<f7>") 'org-capture)
      ;; currently clocked item
      (global-set-key (kbd "C-<f7>") (lambda () (interactive) (org-capture nil "c")))
      ;; default
      (global-set-key (kbd "S-<f7>") (lambda () (interactive) (org-capture nil "w")))
      
		#+END_SRC

*** Org Modules

		#+BEGIN_SRC emacs-lisp
			;; need to do some cleanup here.
			(setq org-modules '(org-bbdb org-bibtex org-docview org-gnus 
																	 org-info org-jsinfo org-habit 
																	 org-irc org-mew org-mhe org-rmail 
																	 org-vm org-wl org-w3m))
		#+END_SRC

*** Org Protocol																										 :instw:instl:outlook:

		this is an example on how you could setup windows to accept
		org-protocol: urls and route them to emacsclientw. the path on the
		last row is the bit you might need to adapt for your installation.
		
		#+BEGIN_EXAMPLE
      Windows Registry Editor Version 5.00
      
      [HKEY_CLASSES_ROOT\org-protocol]
      @="URL:Org Protocol"
      "URL Protocol"=""
      [HKEY_CLASSES_ROOT\org-protocol\shell]
      [HKEY_CLASSES_ROOT\org-protocol\shell\open]
      [HKEY_CLASSES_ROOT\org-protocol\shell\open\command]
      @="C:\Users\jiha\emacs-24.1\bin\emacsclientw.exe %1"
		#+END_EXAMPLE

		for linux you could configure gnome like this.

		#+BEGIN_EXAMPLE
      gconftool-2 -s /desktop/gnome/url-handlers/org-protocol/command '/usr/local/bin/emacsclient %s' --type String
      gconftool-2 -s /desktop/gnome/url-handlers/org-protocol/enabled --type Boolean true
		#+END_EXAMPLE

***** adobe acrobat reader																									 :instw:insti:

			Add these scripts to <somewhere>\Adobe\Reader 10.0\Reader\Javascripts makes it easy
			to takes notes from pdf's and store links to where they are.
			
			#+BEGIN_EXAMPLE javascript
        // from http://article.gmane.org/gmane.emacs.orgmode/6810
        app.addMenuItem({cName:"org-capture", 
                        cParent:"Tools", 
                        cExec:"app.launchURL('org-protocol://capture://' + 
                                              encodeURIComponent(this.URL) + 
                                              '/' + 
                                              encodeURIComponent(this.info.Title) + 
                                              '/');"});
			#+END_EXAMPLE
			
			#+BEGIN_EXAMPLE javascript
        // from http://article.gmane.org/gmane.emacs.orgmode/6810
        app.addMenuItem({cName:"org-store-link", cParent:"Tools",
                         cExec:"app.launchURL('org-protocol://store-link://' + 
                                               encodeURIComponent(this.URL) + 
                                               '/' + 
                                               encodeURIComponent(this.info.Title));"});
			#+END_EXAMPLE

***** Web-browser integration

			Add these as bookmarks in webbrowsers

			#+BEGIN_EXAMPLE javascript
        javascript:location.href='org-protocol://capture://'+ encodeURIComponent(location.href)+'/'+ encodeURIComponent(document.title)+'/'+ encodeURIComponent(window.getSelection())
			#+END_EXAMPLE
			
			#+BEGIN_EXAMPLE javascript
        javascript:location.href='org-protocol://store-link://' + encodeURIComonent(location.href) + '/' + encodeURIComponent(document.title)
			#+END_EXAMPLE

*** Org Capture
		:LOGBOOK:
		CLOCK: [2013-03-28 to 22:48]--[2013-03-28 to 23:26] =>  0:38
		:END:
		
		This is needed by both the [[Org-outlook integration]] and by 
		[[Org Protocol]]. First some basic setup of org-capture.

		We need some good capture templates. remember that the template
		"key" need to be exactly one character long for it to work with
		org-protocol.

		org-capture-templates is a list with structs the tells how and
		where things shall be put. first we clear it then we use
		add-to-list to append template after template.

		#+BEGIN_SRC emacs-lisp
      ;; clear the templates list
      (setq org-capture-templates '())
      
      ;; next we start to add the templates we want.
      ;; This is the default one.
      (add-to-list 'org-capture-templates
                   ;; w has special meaning as a default for capture.
                   '("w"
                     "Default template"
                     entry
                     (file+headline "~/org/capture.org" "Notes")
                     "** %^{Title}
         Added: %U
         Source: %c
         %i
      "
                     :empty-lines 1))
      
      ;; This one is called from my integration in outlook throu org-protocol
      ;; Only useful on my workmachine but is not in the way on my home machine
      ;; Placeholders Replacement 
      ;; %:link URL of the email
      ;; %:description The title of the message
      ;; %:title The title of the message 
      ;; %:initial Selected text.
      ;; %:sender Sender's name
      ;; %:sender-email Sender's Email
      (add-to-list 'org-capture-templates
                   '("o"
                     "Outlook integration - creates items from mails."
                     entry
                     (file+headline "c:/Users/jiha.POWELASA/Documents/org/mdms/mdms.org" 
                                    "Inbox")
                     "** TODO %c :%:sender:
         Added: %U
         %?
      ,   #+begin_quote
           %:initial
      ,   #+end_quote
      "
                     :clock-resume
                     :empty-lines 1
                     :prepend))
      
      ;; This template is used to add notes to currently clocked-in work item.
      (add-to-list 'org-capture-templates
                   '("c"
                     "Add note to currently clocked-in item."
                     entry
                     (clock)
                     "** %^{Title}
         Added: %U
         %?"
                     :clock-keep
                     :empty-lines 1
                     :unnarrowed))
      
		#+END_SRC


***** Things that could be used in templates

			- %[file] :: Insert the contents of the file given by file.
			- %(sexp) :: Evaluate Elisp sexp and replace with the result.
									 The sexp must return a string.
			- %<...>	::	The result of format-time-string on the ... format specification.
			- %t :: Timestamp, date only.
			- %T :: Timestamp, with date and time.
			- %u, %U :: Like the above, but inactive timestamps.
			- %i :: Initial content, the region when capture is called while the region is
							active. The entire text will be indented like %i itself. 
			- %a :: Annotation, normally the link created with org-store-link.
			- %A :: Like %a, but prompt for the description part.
			- %l :: Like %a, but only insert the literal link.
			- %c :: Current kill ring head.
			- %x :: Content of the X clipboard.
			- %k :: Title of the currently clocked task.
			- %K :: Link to the currently clocked task.
			- %n :: User name (taken from user-full-name).
			- %f :: File visited by current buffer when org-capture was called.
			- %F :: Full path of the file or directory visited by current buffer.
			- %:keyword :: Specific information for certain link types, see below.
			- %^g :: Prompt for tags, with completion on tags in target file.
			- %^G :: Prompt for tags, with completion all tags in all agenda files.
			- %^t :: Like %t, but prompt for date.	Similarly %^T, %^u, %^U. You may define a
							 prompt like %^{Birthday}t. 
			- %^C :: Interactive selection of which kill or clip to use.
			- %^L :: Like %^C, but insert as link.
			- %^{prop}p :: Prompt the user for a value for property prop.
			- %^{prompt} :: prompt the user for a string and replace this sequence with it.	 You
											may specify a default value and a completion table with
											%^{prompt|default|completion2|completion3...}.	The arrow keys
											access a prompt-specific history.
			- %\n :: Insert the text entered at the nth %^{prompt}, where n is a number,
							 starting from 1.
			- %? :: After completing the template, position cursor here.


			For specific link types, the following keywords will be defined2:


      | Link type                       | Available keywords                                     |
      |---------------------------------+--------------------------------------------------------|
      | bbdb                            | %:name %:company                                       |
      | irc                             | %:server %:port %:nick                                 |
      | vm, vm-imap, wl, mh, mew, rmail | %:type %:subject %:message-id                          |
      |                                 | %:from %:fromname %:fromaddress                        |
      |                                 | %:to   %:toname   %:toaddress                          |
      |                                 | %:date (message date header field)                     |
      |                                 | %:date-timestamp (date as active timestamp)            |
      |                                 | %:date-timestamp-inactive (date as inactive timestamp) |
      |                                 | %:fromto (either "to NAME" or "from NAME")3            |
      |---------------------------------+--------------------------------------------------------|
      | gnus                            | %:group, for messages also all email fields            |
      | w3, w3m                         | %:url                                                  |
      | info                            | %:file %:node                                          |
      | calendar                        | %:date                                                 |

*** Standard Todo states and transitions
		:LOGBOOK:
		- State "DONE"			 from "TODO"			 [2012-08-20 må 17:19]
		:END:

		This is from [[norang:TodoKeywords]] it's proberbly more than I need.
		#+BEGIN_SRC emacs-lisp
      (setq org-todo-keywords
            (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d@/@)")
                    (sequence "WAITING(w@/!)" "|" "CANCELLED(c@/!)")
										(sequence "HOLD(h@/!)" "|" "CANCELLED(c@/!)")
                    (sequence "INVESTIGATE(i@/!)" "BUG(b@/!)" "|" "NOT_A_BUG(!)" "FIXED(f@/@)")
                    (sequence "ESTIMATE" "|" "ESTIMATED"))))
      
		#+END_SRC

*** Org todo keyword faces																												 :faces:

		All kewords are should be bold, that tells me they are keywords
		#+BEGIN_SRC emacs-lisp

		#+END_SRC

*** Init

		because I have more than one computer and also a work computer, I have split my org
		agenda files into X number of parts. One that I share between computers and one that
		is local to that machine(or filesystem I am working in). To make configuration of
		org-agenda work with this I have a list of directories called my-org-directories and
		will call special files in those directories at specific times

		#+BEGIN_SRC emacs-lisp
      ;; for every directory in my-org-directories call init.org
      ;; every init.org file may setup local-org-agenda-files with files that should form a part
      ;; of the org agenda this is added to org-agenda-files here with directory concated
      ;; before. 
      (dolist (directory my-org-directories) 
        (let ((local-org-agenda-files '())
              (local-org-directory directory))
          (org-babel-load-file (concat directory "init.org"))
          (dolist (file local-org-agenda-files)
            (add-to-list 'org-agenda-files (concat directory file)))))
          
		#+END_SRC

  #+RESULTS:

*** Org-outlook integration																								 :instw:outlook:

		using the org-outlook from melpa and follows instructions

*** Refile

		#+BEGIN_SRC emacs-lisp
      (setq org-log-refile 'note)
      (setq org-refile-allow-creating-parent-nodes 'confirm)
      (setq org-refile-targets 
            '((org-agenda-files :maxlevel . 5)))
      (setq org-refile-use-cache t)
      (setq org-refile-use-outline-path 'file)
      
		#+END_SRC

*** Smarter headlines

		from: http://lists.gnu.org/archive/html/emacs-orgmode/2007-10/msg00551.html
		Hi,
		
		Here's a small piece of elisp code that might be useful to some of you. Pressing '*'
		now inserts '*' as before, but if there are only spaces between the beginning of the
		current line and the point, then all of them are converted to stars. Useful for
		inserting new headlines.
		
		Longer explanaition: assume you have the following structure:
		
		#+BEGIN_EXAMPLE
      * first level headline
      _* second level headline
      __* third level headline
		#+END_EXAMPLE

		(_ denotes an invisible star) Since stars are invisible, I often find myself trying to
		create a new subheadline by just inserting a single star

		#+BEGIN_EXAMPLE
      * first level headline
      _* second level headline
      __* third level headline
         *
		#+END_EXAMPLE

		which of course doesn't normally work, hence this elisp code.

		#+BEGIN_SRC emacs-lisp
      (defun local-org-insert-stars ()
        (interactive)
        (when (looking-back "^ *" (point-at-bol))
          (replace-string " " "*" nil (point-at-bol) (point)))
        (insert "*"))
      
      (define-key org-mode-map "*" 'local-org-insert-stars)
		#+END_SRC

		Haven't thoroughly tested it, but it seems to work ok.

		Piotr

*** Filesets for OrgFiles																												:filesets:

		Creates filesets for all org files.
    #+BEGIN_SRC emacs-lisp
      (dolist (directory my-org-directories)
        (let ((directory-part (concat "Org: " (car (last (split-string directory "/") 2)))))
          (add-to-list 'filesets-data 
                       (list directory-part
                             (list ':tree
                                   directory
                                   "^.+\\.org$")))))
		#+END_SRC

    #+RESULTS:

*** Logging and clocking
    
    I want to have the chance to enter a message for every change a
    make to items that are scheduled and for what I make with my
    time. It's easy to ignore if not needed I just pres C-c C-c, and no
    message will be saved.

    #+BEGIN_SRC emacs-lisp
      (setq org-clock-into-drawer t)
      (setq org-log-into-drawer t)
      (setq org-log-redeadline (quote note))
      (setq org-clock-clocked-in-display 'frame-title)
      ;; Show lot of clocking history so it's easy to pick items off the list
      (setq org-clock-history-length 25)
      ;; Resume clocking task on clock-in if the clock is open
      (setq org-clock-in-resume t)
      ;; This removes clocked tasks with 0:00 duration
      (setq org-clock-out-remove-zero-time-clocks t)
      ;; Clock out when moving task to a done state
      (setq org-clock-out-when-done t)
      ;; Do not prompt to resume an active clock
      (setq org-clock-persist-query-resume nil)
      ;; Enable auto clock resolution for finding open clocks
      (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
      ;; Include current clocking task in clock reports
      (setq org-clock-report-include-clocking-task t) 
    #+END_SRC
    

		The Commands for clocking in and clocking out are by default only bound in org-mode
		this means I always have to switch to a org-mode buffer and that annoys me very
		much. Therefor we bind function that have to do with to F2

		#+BEGIN_SRC emacs-lisp
      (let ((key "<f2>"))
        (add-hook 'org-mode-hook (lambda () (local-set-key [f2] 'org-clock-in)))
        (add-hook 'org-agenda-mode-hook (lambda () (local-set-key [f2] 'org-agenda-clock-in)))
        (global-set-key (kbd key) 'org-clock-in)
        (global-set-key (kbd (concat "M-" key)) 'org-clock-goto)
        (global-set-key (kbd (concat "S-" key)) 'org-clock-out)
        ;; This binds C-key to list last X clocked items and let me choose easy between which
        ;; one of them I should clock into, just like as if I hade called org-clock-in with a
        ;; prefix (C-u)
        (global-set-key (kbd (concat "C-" key)) (lambda () (interactive)
                                      (let ((current-prefix-arg '(4))) 
                                        (call-interactively 'org-clock-in)))))
		#+END_SRC

		
*** Agenda																																 :habits:agenda:

		#+BEGIN_SRC emacs-lisp
      ;; popup new frame for org-agenda, so we get full width
      ;; it will reuse allready open frame and only pop it front.
      (setq org-agenda-window-setup 'other-frame)
      
      (setq org-agenda-ndays 14)
      (setq org-agenda-repeating-timestamp-show-all nil)
      (setq org-agenda-include-diary t)
      (setq org-agenda-inhibit-startup t)
      (setq org-agenda-clock-consistency-checks 
            (quote (:max-duration "10:00" 
                    :min-duration "00:03" 
                    :max-gap "0:05" 
                    :gap-ok-around ("4:00" "12:00") 
                    :default-face ((:background "DarkRed") 
                                   (:foreground "white")) 
                    :overlap-face nil 
                    :gap-face nil 
                    :no-end-time-face nil 
                    :long-face nil 
                    :short-face nil)))
      (setq org-agenda-clockreport-parameter-plist 
             (quote (:link t :maxlevel 3)))
      (setq org-agenda-dim-blocked-tasks t)
      (setq org-agenda-entry-text-maxlines 3)
      (setq org-agenda-skip-deadline-if-done t)
      (setq org-agenda-skip-scheduled-if-done t)
      (setq org-agenda-time-leading-zero t)
      
      ;; habits, and modification of tags column so it's not in way of habits
      (setq org-habit-graph-column 70)
      (setq org-agenda-tags-column 110)
      (setq org-habit-show-habits-only-for-today nil)
      (setq org-habit-preceding-days 20)
      (setq org-habit-following-days 15)
      
		#+END_SRC

		#+RESULTS:
		: 15

		From Julien Danjou we borrow a function to be able to get our own
		Holidays and Vaction days marked in the right face.	 for this to
		kick in you need to set the category on items to "Holidays" or
		"Vacation".

		#+BEGIN_SRC emacs-lisp
      (setq org-agenda-day-face-function
            (defun jd:org-agenda-day-face-holidays-function (date)
              "Compute DATE face for holidays."
              (unless (org-agenda-todayp date)
                (dolist (file (org-agenda-files nil 'ifmode))
                  (let ((face
                         (dolist (entry (org-agenda-get-day-entries file date))
                           (let ((category (with-temp-buffer
                                             (insert entry)
                                             (org-get-category (point-min)))))
                             (when (or (string= "Holidays" category)
                                       (string= "Vacation" category))
                               (return 'org-agenda-date-weekend))))))
                    (when face (return face)))))))
		#+END_SRC
		
***** Agenda templates
			#+BEGIN_SRC emacs-lisp
        ;(setq org-agenda-custom-commands
        ;  '(("h" . "HOME + Name tag searches") ; describe prefix "h"
        ;    ("hl" tags "+HOME+Lisa")
        ;    ("hp" tags "+HOME+Peter")
        ;    ("hk" tags "+HOME+Kim")))

			#+END_SRC

***** Diary integration																						:appt:midnight:calendar:

			functions to use in the agenda view, include calles to these
			functions in one of your agenda files like this %%(diary-sun*) and
			it will be called.
			#+BEGIN_SRC emacs-lisp
        ;; functions to use in the dairy to get seperated sunrise and sunset times.
        ;; if we use %%(dairy-sunrise-sunset) we get it on one line, this gives us
        ;; two lines or only one if we want to.
        (defun diary-sunrise ()
          (let ((dss (diary-sunrise-sunset)))
            (with-temp-buffer
              (insert dss)
              (goto-char (point-min))
              (while (re-search-forward " ([^)]*)" nil t)
                (replace-match "" nil nil))
              (goto-char (point-min))
              (search-forward ",")
              (buffer-substring (point-min) (match-beginning 0)))))
        
        (defun diary-sunset ()
          (let ((dss (diary-sunrise-sunset))
                start end)
            (with-temp-buffer
              (insert dss)
              (goto-char (point-min))
              (while (re-search-forward " ([^)]*)" nil t)
                (replace-match "" nil nil))
              (goto-char (point-min))
              (search-forward ", ")
              (setq start (match-end 0))
              (search-forward " at")
              (setq end (match-beginning 0))
              (goto-char start)
              (capitalize-word 1)
              (buffer-substring start end))))
        
			#+END_SRC
			
			We also need to set where on earth we are because without that
			information the dairy-sun* functions can not do it's job and
			will ask every time we start where on earht we are.

			#+BEGIN_SRC emacs-lisp
        (setq calendar-latitude 63.1766)
        (setq calendar-longitude 14.636068)
        (setq calendar-location-name "Östersund, Sweden")
        
			#+END_SRC

			Midnight hook to get org appointments into the appt reminder things
			
			#+BEGIN_SRC emacs-lisp
        ; on startup
        (org-agenda-to-appt)
        ; every night we update
        (add-hook 'midnight-hook (lambda ()
                                   (org-agenda-to-appt)))
			#+END_SRC

   #+RESULTS:
	 | (lambda nil (org-agenda-to-appt)) | clean-buffer-list |

*** Exports
*** Babel
		
		#+BEGIN_SRC emacs-lisp
      ;; We want some more languages than emacs-lisp to be usable in src blocks.
      (setq org-babel-load-languages 
            '((sql . t) 
              (emacs-lisp . t) 
              (org . t) 
              (C . t)))
      ;; font-lock in src blocks
      (setq org-src-fontify-natively t)
      
		#+END_SRC

***** SQL
      Sometimes I use sql in org-babel, for that I have modified version
      of [[ob-sql.el]] my modifications are so I can use it together with
      oracle. It still need some more fixing before a send a patch for it
      to the maintainers.

      #+BEGIN_SRC emacs-lisp
        ;; we use a safe way of loading it, it should alawys exist but if it
        ;; does not, we don't want an error.
        (jiha-safe-require 'ob-sql
                          (message "loaded ob-sql, you can now use sql in org-babel snippets"))
        
      #+END_SRC
******* TODO does not work at the moment
				
				we get the standard ob-sql that is included with org-mode instead of my modified
				version that have support for oracle. we could send it upstream to get it
				included or find a way to force loading of my version

*** Org-sync
*** Post

		Read [[Init]]. here is the last call and it gives the local a chance to overide everything
		from the shared org-directory. This calls post.org in reverse order compared to init.
		
		#+BEGIN_SRC emacs-lisp
      ;; calling post in all org-directories
      (dolist (directory (reverse my-org-directories))
        (let ((local-org-directory directory))
          (org-babel-load-file (concat directory "post.org"))))
      
		#+END_SRC

  #+RESULTS:

*** Clock

		#+BEGIN_SRC emacs-lisp
      ;; Save the running clock and all clock history when exiting Emacs, load it on startup
      (setq org-clock-persist t)      
			(org-clock-persistence-insinuate)
		#+END_SRC
* Google Integration
	most of these things comes from http://julien.danjou.info/
*** Google maps																																			 :org:

		using melpa version

    You can then use M-x google-maps and type a location.
    
    Various key bindings are available. Here's a few:
    
    - + or - :: to zoom in or out;
    - left, right, up, down :: to move;
    - z :: to set a zoom level via prefix;
    - q :: to quit;
    - m :: to add or remove markers;
    - c :: to center the map on a place;
    - C :: to remove centering;
    - t :: to change the maptype;
    - w :: to copy the URL of the map to the kill-ring;
    - h :: to show your home.

    You can integrate directly Google Maps into Org-mode:

    Then you can use C-c M-L to enter a location assisted by Google
    geocoding service. Pressing C-c M-l will show you a map.

    If you want to use advanced feature, you should take a look at
    google-maps-static-show and google-maps-geocode-request functions.
*** Google Contacts																																:oauth2:

		using melpa version
    
    Various key bindings are available. Here's a few:
    
    n or p to go the next or previous record;
    g to refresh the result, bypassing the cache;
    m to send an e-mail to a contact;
    s to make a new search;
    q to quit.

    Then you can use TAB to go to complete e-mail addresses in the
    header fields.
* Other Setup																																 :keybindings:

	#+BEGIN_SRC emacs-lisp
    (setq-default indent-tabs-mode t)
    (global-set-key "\C-x\C-l" 'goto-line)
    
	#+END_SRC

* Load Local settings

	Last but not least we need to load the part of the .emacs that is
	local to this machine. That is also a org-babel emacs file.

	#+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path (concat local-emacs-org-dir "local"))
    (org-babel-load-file (concat local-emacs-org-dir "local/emacs.org"))
	#+END_SRC
  
* File-sets																																			:filesets:
	
	The commands that can operate on file sets are specified in the global
	custom variable "filesets-commands". You can add your own commands to
	that list. The default value for this variable is: 
	
	#+BEGIN_EXAMPLE emacs-lisp
    ("Isearch" multi-isearch-files
    (filesets-cmd-isearch-getargs))
    ("Isearch (regexp)" multi-isearch-files-regexp
    (filesets-cmd-isearch-getargs))
    ("Query Replace" perform-replace
    (filesets-cmd-query-replace-getargs))
    ("Query Replace (regexp)" perform-replace
    (filesets-cmd-query-replace-regexp-getargs))
    ("Grep <<selection>>" "grep"
    ("-n " filesets-get-quoted-selection " " "<<file-name>>"))
    ("Run Shell Command" filesets-cmd-shell-command
    (filesets-cmd-shell-command-getargs)))  
	#+END_EXAMPLE
	
	The values consist of an association list of names, functions, and an
	argument list (or a function that returns one) to be run on a
	filesets' files. So, if you wanted to add a command that does an
	"occur" command on the file set, you could use the "Isearch" entry as
	an example to create your own new entry (that you would add to the
	"filesets-commands" global variable) that would look something like: 
	
	("Occur (regexp)" multi-occur-files-regexp
	(filesets-cmd-occur-getargs))
	
	You would need to write the "multi-occur-files-regexp" and
	"filesets-cmd-occur-getargs" functions (you could use the existing
	"multi-isearch-files-regexp" and "filesets-cmd-isearch-getargs"
	functions as a basis since they would be similar). The same would
	apply for any additional Emacs command that you wanted to add to work
	on file sets. 
	
	#+BEGIN_SRC emacs-lisp
    ;; now when all org-directories has been parsed we should be
    ;; able to init the filesets menu.
    (filesets-init)
	#+END_SRC
	
* ERC

	#+BEGIN_SRC emacs-lisp
    (jiha-safe-require 'erc-join ())    
    (jiha-safe-require 'erc-match ())
    (setq erc-keywords '("darion" "kurohin"))
    
    ;; Exclude messages sent by the server when you join a channel, such as the nicklist and topic:
    (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                    "324" "329" "332" "333" "353" "477"))
    
    (defun jiha-erc-after-connect-hook (SERVER NICK))
    
    (add-hook 'erc-after-connect 'jiha-erc-after-connect-hook)
    
    (erc-autojoin-mode 1)
    (setq erc-autojoin-channels-alist
          ;; localhost should have a ssh tunnel to my server
          '(("localhost" "#emacs" "#org-mode" "#erc")
            ("irc.freenode.net" "#emacs" "#org-mode" "#erc")
            ("oftc.net" "#BitlBee")))
    
    (defun irc-maybe ()
      "Connect to IRC."
      (interactive)
      (when (y-or-n-p "IRC? ")
        ;; should be a ssh tunnel to freenode
        (erc :server "localhost" :port 6667
             :nick "kurohin" :full-name "Jim Hansson")
        ;;(erc :server "irc.oftc.net" :port 6667
        ;;     :nick "kurohin" :full-name "Jim Hansson")
        ;; should be a ssh tunnel to testing.bitlbee.org
        (erc :server "localhost" :port 7000
             :nick "kurohin" :full-name "Jim Hansson")))
    
    ;; logging:
    (setq erc-log-insert-log-on-open nil)
    (setq erc-log-channels t)
    (setq erc-log-channels-directory "~/.irclogs/")
    (setq erc-save-buffer-on-part t)
    (setq erc-hide-timestamps nil)
    
    (defadvice save-buffers-kill-emacs (before save-logs (arg) disable)
      (save-some-buffers t (lambda () (when (and (eq major-mode 'erc-mode)
                                                 (not (null buffer-file-name)))))))
    
    (add-hook 'erc-insert-post-hook 'erc-save-buffer-in-logs)
    (add-hook 'erc-mode-hook '(lambda () (when (not (featurep 'xemacs))
                                           (set (make-variable-buffer-local
                                                 'coding-system-for-write)
                                                'emacs-mule))))
    ;; end logging
    
    ;; Truncate buffers so they don't hog core.
    (setq erc-max-buffer-size 20000)
    (defvar erc-insert-post-hook)
    (add-hook 'erc-insert-post-hook 'erc-truncate-buffer)
    (setq erc-truncate-buffer-on-save t)
    
    (erc-timestamp-mode t)
    (setq erc-timestamp-format "[%R-%m/%d]")
    
    (global-set-key (kbd "C-c I") 'reset-erc-track-mode)
    (setq erc-auto-query 'buffer)
    
	#+END_SRC

* TODO BBDB
* Windows context menu integration																								 :instw:
	:LOGBOOK:
	- State "DONE"       from "TODO"  [2013-03-15 fr 10:35]
		works fine
	CLOCK: [2013-03-15 fr 08:11]--[2013-03-15 fr 10:35] =>  2:24
	:END:
	Starting Emacs From Global Context Menu
	
	Here is a simple but useful way to access Emacs. It adds the option to open a file in
	Emacs to your global context menu (i.e., right clicking on a file). This runs a new
	Emacs instance for each file. (Note: not the “Open With” submenu, but the top level
	context menu.) 

	This has been tested under WinXP.

	Create a file of the code below, change paths to were you have emacs installed and run
	it.

	#+BEGIN_SRC conf-windows
    REGEDIT4      
    [HKEY_CLASSES_ROOT\*\shell]
      
    [HKEY_CLASSES_ROOT\*\shell\openwemacs]
    @="&GNU Emacs (client)"
    # The above value appears in the global context menu, 
    # i.e., when you right click on a file.
    # (The '&' makes the next character a shortcut.)
    "Icon"="C:\\users\\jiha\\Emacs-24.1\\bin\\emacs.exe,0"
    # The above uses the icon of the Emacs exe for the context
    # and should match the path used for the command below.
    # The ,0 selects the main icon.
    
    [HKEY_CLASSES_ROOT\*\shell\openwemacs\command]
    @="C:\\users\\jiha\\Emacs-24.1\\bin\\emacsclientw \"%1\""
    # The above has to point to where you install Emacs 
	#+END_SRC

	If it does not work, check the paths one more time.

* List of others configurations that you can look at and steal ideas from

	- Julien Danjou :: http://git.naquadah.org/git/~jd/emacs.d.git
	- Thomas Krennwallner's :: http://www.postsubmeta.net/MyConfig/Emacs 
	
* Variable list @ end of file

	Thanks to local file variables is implemented in a little special way that has to do
	with how it detects comments it's possible to have this part functional in both
	emacs.org and in the exported emacs.el

	#+BEGIN_SRC emacs-lisp
    ;; Local Variables:
    ;; tab-width: 2;
    ;; LocalWords: Uniquify Iswitch emacs src Whitespace Google LocalWords BBDB SQL PLSQL nXML Krennwallner's
    ;; End:
	#+END_SRC
