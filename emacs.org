# -*- mode: org -*-
#+TITLE: My emacs configuration
#+AUTHOR: Jim Hansson
#+EMAIL: jim.hansson@gmail.com
#+DATE: <2012-06-28 to>
#+LANGUAGE: english
#+STARTUP: hidestars hideblocks
#+COLUMNS: %50ITEM %4TODO %20TAGS
This is my main .emacs file. It is responsible for calling out to the
local file at different points. This is placed in a git repository
that I share between work and home

* Introduction
  Basic things that could have been down throu custom-set-variable but
  then I would have harder time to replicate that between machines.

** Requirements

   - Emacs 24
   - a basic .emacs file that calls this after it inits org-babel 
   - a lot of extra packages. most configuration will check for it
     
** Other important stuff
*** Only load things that exists.

    that can be done this way, use this to avoid errors on machine
    which don't have every package installed.

    #+begin_example
      (when (require 'deft nil 'noerror) 
      (setq
         deft-extension "org"
         deft-directory "~/Org/deft/"
         deft-text-mode 'org-mode)
      (global-set-key (kbd "<f9>") 'deft))
    #+end_example

** Setup

   Here we setup some basic things, I dont like the toolbar so that we
   turn off, I use OrgMode to almost everything(even my .emacs) so
   that will be my default mode. Almost all computers I use are
   laptops and who in there right mind uses 12h clocks.

   #+begin_src emacs-lisp
     (tool-bar-mode -1)
     (setq default-major-mode 'org-mode)
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
     (setq display-battery-mode t)
     (setq display-time-24hr-format t)
     (iswitchb-mode 1)
     ;; show matching paren
     (show-paren-mode t)
     ;; I work width some really big files and then it is good to have this
     ;; so i know how far down I am.
     (size-indication-mode t)
   #+end_src

** Uniquify                                                :uniquify:buffers:

   Better naming of buffers so we can easly tell the differens between
   buffers. Have some problem together with Iswitch

   #+begin_src emacs-lisp
     (require 'uniquify)
     (setq uniquify-buffer-name-style (quote post-forward))
   #+end_src

** Disable warnings for first time users
   
   For some reason some questions in emacs are yes/no and some are y/n
   this trips me sometimes so we turn that off, and the same goes for
   killing emacs. We also removes some questions that are asked to
   make sure that the users really wants what is going to happen, I
   know how to use undo and else I usually have some version control
   system running so I can go back.

   #+begin_src emacs-lisp
     ;; Changes all yes/no questions to y/n type
     (fset 'yes-or-no-p 'y-or-n-p)
     (set-variable 'confirm-kill-emacs 'yes-or-no-p)
     ;; more of these as I find them
     (put 'narrow-to-region 'disabled nil)
   #+end_src

* Iswitch Buffers                                                   :buffers:

  some text here.
  To prevent certain buffers from showing up in the completion list,
  set 'iswitchb-buffer-ignore': (setq iswitchb-buffer-ignore '("^ "
  "*Buffer")) This one is useful if you want to lose the *...*
  special buffers from the list. It's helpful if you're using the
  JDEE for editing Java apps, as you end up with buffers named
  org.whatever.package.Class which you might want to eliminate: (setq
  iswitchb-buffer-ignore '("^\\*")) To prevent switching to another
  frame, you can add the following to your configuration: (setq
  iswitchb-default-method 'samewindow)

  #+begin_src emacs-lisp
    (iswitchb-mode 1)
    (setq iswitchb-default-method 'samewindow)
    ;; in your .emacs will allow left/right artist--arrow key navigation of the
    ;; buffer list, and deactivate up/down in iswitchb. Note that you
    ;; can by default use C-s and C-r to do this.  If the
    ;; below fails with "define-key: Symbol's function definition is
    ;; void: edmacro-parse-keys" you need to load the package defining
    ;; edmacro with (require 'edmacro).
    (defun iswitchb-local-keys ()
      (mapc (lambda (K) 
              (let* ((key (car K)) (fun (cdr K)))
                (define-key iswitchb-mode-map (edmacro-parse-keys key) fun)))
            '(("<right>" . iswitchb-next-match)
              ("<left>"  . iswitchb-prev-match)
              ("<up>"    . ignore             )
              ("<down>"  . ignore             ))))
    (add-hook 'iswitchb-define-mode-map-hook 'iswitchb-local-keys)
  #+end_src

** Iswitch and uniquify compabilitiy                               :uniquify:

   The library uniquify overrides Emacs default mechanism for making
   buffer names unique (using suffixes like <2>, <3> etc.) with a
   more sensible behaviour which use parts of the file names to make
   the buffer names distinguishable.  Additionally one can configure
   uniquify to rework the buffer names whenever a buffer is
   killed. This feature does not play well with IswitchBuffers
   function iswitchb-kill-buffer, bound to C-k. The following code
   instructs iswitchb-kill-buffer to update the buffer list after
   killing a buffer, so that a possible buffer renaming by uniquify
   is taken in account.

   #+begin_src emacs-lisp
     (defadvice iswitchb-kill-buffer (after rescan-after-kill activate)
       "*Regenerate the list of matching buffer names after a kill.
     Nextcessary if using `uniquify' with `uniquify-after-kill-buffer-p'
     set to non-nil."
       (setq iswitchb-buflist iswitchb-matches)
       (iswitchb-rescan))
     
     (defun iswitchb-rescan ()
       "*Regenerate the list of matching buffer names."
       (interactive)
       (iswitchb-make-buflist iswitchb-default)
       (setq iswitchb-rescan t))
   #+end_src


** More Iswitch things that I don't use at the moment
*** Keybindings

    Something most IswitchBuffers users aren't aware of is that you
    can hit C-k to kill the currently selected buffer.

*** Using Iswitch-Buffer Programmatically
    
    From: KinCho
    Subject: my-icompleting-read
    Newsgroups: gnu.emacs.sources
    Date: Tue, 09 Oct 2001 16:28:18 GMT
    
    I used iswitchb for a while and really liked it. I began to
    explore to see if I can borrow iswitchb to make my scripts work
    like iswitchb as well. Well, it turned out iswitchb is coded in a
    way that makdes it really easy to borrow it to do regex-style
    completing-read: 

    (defun my-icompleting-read(prompt choices)
    (let ((iswitchb-make-buflist-hook
    (lambda ()
    (setq iswitchb-temp-buflist choices))))
    (iswitchb-read-buffer prompt)))

    Another example. Two things. "nil t" to iswitchb-read-buffer
    requires a choice from the given list with no default. Using an
    flet is a way to work when there's no hook variable. There is a
    hook variable. 

    (defvar interesting  (regexp-opt '(".c" ".h" "etc.")))
    (defvar some-directory "/home/somewhere/etc/")

    ;; Making this more flexible is an exercise for the reader
    (defun find-a-file (arg &optional non-selective)
    "Select files using substrings."
    (interactive "sFile: ")
    (let ((dir (expand-file-name some-directory))
    candidates)
    (flet ((file-match (file)
    (if non-selective
    (string-match arg file)
    (and
    (string-match interesting file)
    (string-match arg file)))))
    (setq candidates (delq nil (loop for file in (directory-files dir)
    collect (if (file-match file) file)))))
    (cond
    ((eq (length candidates) 1)
    (find-file (format "%s%s" dir (car candidates))))
    ((eq (length candidates) 0)
    (if non-selective
    (message "No such file!")
    (find-a-file arg t)))
      (t
      (flet ((iswitchb-make-buflist (default)
      (setq iswitchb-buflist candidates)))
      (find-file (format 
      "%s%s" dir
      (iswitchb-read-buffer "File: " nil t))))))))
      
    I'm quite new to iswitchb. I've been after eliminating the need to
    confirm (with TAB or ret) the last left possibility. 
      
    I've started with this simple hack, which only displays the
    desired buffer, but in this way, i don't need to look at the
    minibuffer (in some cases). 
    
    (defun iswitchb-post-command ()
    "Run after command in 'iswitchb-buffer'."
    (iswitchb-exhibit)
    (if (= (length iswitchb-matches) 1)
    (display-buffer (car iswitchb-matches))))
    
    another thing i like, is to have the freedom to decide to open the buffer in other-window/frame after i made the selection: Hence a new minibuffer exiting command:
    
    (defun iswitchb-select-buffer-other-window ()
    "Select the buffer named by the prompt. But in another window."
    (interactive)
    (setq iswitchb-method 'otherwindow)
    (exit-minibuffer))
    
    The functionality of iswitchb can also be used to provide a replacement for the usual behaviour of find-file. Instead of hitting Tab to bring up a buffer listing the possible file completions, a list of file completions is continuously updated in the minibuffer:
    
    (defun exd-find-file ()
    "Use functionality from `iswitchb' as a replacement for `find-file'"
    (interactive)
    (find-file (exd-iswitchb-find-file "." (directory-files "."))))
    
    (defun exd-iswitchb-find-file (dir file-list)
    "Use functionality from `iswitchb' to select a file for `find-file'.
    If a directory is selected, enter that directory and generate a new
    list from which to select a file."
    ;; sort the file list into directories first
    (setq file-list
    (sort file-list
    (lambda (elt-1 elt-2)
    (and (file-directory-p (concat dir "/" elt-1))
    (not (file-directory-p (concat dir "/" elt-2)))))))
    ;; use iswitchb for minibuffer file list/completion magic
    (let* (resize-mini-windows
    (iswitchb-make-buflist-hook
    (lambda ()
    (setq iswitchb-temp-buflist file-list)))
    ;; get the selected file
    (selected-file (concat dir "/" (iswitchb-read-buffer
    (concat "Find File: "
    (expand-file-name dir)
    "/")))))
    ;; if the selected file is a directory, recurse, else return file
    (if (file-directory-p selected-file)
    (exd-iswitchb-find-file selected-file (directory-files selected-file))
    selected-file)))
    
    See Also:
    
    Icicles, and command 'icicle-buffer', which is similar to
    'iswitchb-buffer' but provides some additional features. Also,
    Icicles treats all types of minibuffer input the same way:
    filenames, buffer names, commands, variables...everything. And it
    lets you use a regexp to match completions, if you like. 
    InteractivelyDoThings (ido), which implements regex selection for
    files, directory buffers etc...

* TODO Coding

  Here I will place everything that has todo with coding

** TODO Coding styles

* OrgMode
** Basic
   #+begin_src emacs-lisp
     (setq org-deadline-warning-days 7)
     (setq org-timeline-show-empty-dates t)
     (setq org-agenda-include-diary nil)
     ;; resurect clock and clocking history
     (org-clock-persistence-insinuate)
   #+end_src

  A large part of the configuration has to do with how org should
  behave. it's a pretty complex mode with lot of things you could
  change. I have tried to make it as simple a possible with sub-trees
  for every main function of OrgMode.

  #+begin_src emacs-lisp
    (setq org-agenda-exporter-settings
          '((ps-number-of-columns 1)
            (ps-landscape-mode t)
            (htmlize-output-type 'css)))
    
    (setq org-agenda-custom-commands
          '(
            
            ("P" "Projects"   
             ((tags "PROJECT")))
            
            ("H" "Office and Home Lists"
             ((agenda)
              (tags-todo "OFFICE")
              (tags-todo "HOME")
              (tags-todo "COMPUTER")
              (tags-todo "DVD")
              (tags-todo "READING")))
            
            ("D" "Daily Action List"
             (
              (agenda "" ((org-agenda-ndays 1)
                          (org-agenda-sorting-strategy
                           (quote ((agenda time-up priority-down tag-up) )))
                          (org-deadline-warning-days 0)
                          ))))
            )
          )
    
    (defun gtd ()
      (interactive)
      (find-file "~/Dokument/GTD/gtd.org")
      )
    (global-set-key (kbd "C-c g") 'gtd)
    
    (add-hook 'org-agenda-mode-hook 'hl-line-mode)
    
  #+end_src

** Init

   because I have more than one computer and also a work computer, I
   have split my org agenda files into two parts. One that I share
   between computers and one that is local to that machine(or
   filesystem I am working in). To Make configuration of org-agenda
   work with this I have files that I call in my shared org directory
   and in my local directory. So here is the first call.

   #+begin_src emacs-lisp
     (org-babel-load-file (concat local-org-files-dir "init.org"))
     (org-babel-load-file (concat shared-org-files-dir "init.org"))
   #+end_src

** Logging and clocking
   
   I want to have the change to enter a message for every change a
   make to items that are scheduled and for what I make with my
   time. It's easy to ignore if not needed I just pres C-c C-c, and no
   message will be saved.

   #+begin_src emacs-lisp
     (setq org-clock-into-drawer t)
     (setq org-log-into-drawer t)
     (setq org-log-redeadline (quote note))
   #+end_src

** TODO Agenda
   
   this a big part

** TODO Exports
** Babel
*** SQL
    Sometimes I use sql in org-babel for that I have modified version
    of 'ob-sql.el' my modifications are so I can use it together with
    oracle. It still need some more fixing before a send a patch for it
    to the maintainers.
    #+begin_src emacs-lisp
      ;; we use a safe way of loading it, it should alawys exist but if it
      ;; does not, we don't want an error.
      (when (require 'ob-sql nil 'noerror) 
        (message "loaded ob-sql, you can now use sql in org-babel snippets")
        )
    #+end_src

** Post

   Read [[Init]]. here is the last call and it gives the local a chance to
   overide everything from the shared org-directory.

   #+begin_src emacs-lisp
     (org-babel-load-file (concat shared-org-files-dir "post.org"))
     (org-babel-load-file (concat local-org-files-dir "post.org"))
   #+end_src

* Remember
  
  I don't use remember as much at the moment but some day or some
  other function once I have found out which I shall use. Most of this
  has been copied from someones GTD.org setup.

  #+begin_src emacs-lisp
    (autoload 'remember "remember" nil t)
    (autoload 'remember-region "remember" nil t)
    (setq remember-annotation-functions '(org-remember-annotation))
    (setq remember-handler-functions '(org-remember-handler))
    (add-hook 'remember-mode-hook 'org-remember-apply-template)
    (setq org-remember-templates
         '(
          ("Todo" ?t "** TODO %^{Brief Description} %^g\n%?\nAdded: %U" "~/Dokument/GTD/gtd.org" "Tasks")
          ("Private" ?p "\n* %^{topic} %T \n%i%?\n" "~/Dokument/GTD/gtd.org" "Private")
          ("WordofDay" ?w "\n* %^{topic} \n%i%?\n" "~/Dokument/GTD/wotd.org")
          ))
  #+end_src

* TODO Other Setup
  #+begin_src emacs-lisp
    ; dont use tabs for indenting
    (setq-default indent-tabs-mode nil)
    
    (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
    (define-key global-map "\C-cl" 'org-store-link)
    (define-key global-map "\C-ca" 'org-agenda)
    
    (setq org-log-done nil)
    (setq org-deadline-warning-days 7)
    (setq org-timeline-show-empty-dates t)
    (setq org-insert-mode-line-in-empty-file t)
    
    (setq org-directory "~/Dokument/orgfiles/")
    (setq org-default-notes-file "~/.notes")
    (define-key global-map "\C-cr" 'org-remember)
        
    (define-key global-map [f8] 'remember)
    (define-key global-map [f9] 'remember-region)
    
    (global-font-lock-mode t)
    
    (global-set-key "\C-x\C-r" 'prefix-region)
    (global-set-key "\C-x\C-l" 'goto-line)
    ;;(global-set-key "\C-x\C-y" 'copy-region-as-kill)
  #+end_src

* Load Local settings
  Last but not least we need to load the part of the .emacs that is
  local to this machine. That is also a org-babel emacs file.
  #+begin_src emacs-lisp
    (add-to-list 'load-path (concat local-emacs-org-dir "local"))
    (org-babel-load-file (concat local-emacs-org-dir "local/emacs.org"))
  #+end_src
